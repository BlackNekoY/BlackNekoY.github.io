<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Slim&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Slim&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Slim&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Slim's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Slim's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-24T17:56:00+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OpenGL入门-4-投影和摄像机"><a href="#OpenGL入门-4-投影和摄像机" class="headerlink" title="OpenGL入门(4)-投影和摄像机"></a>OpenGL入门(4)-投影和摄像机</h1><h2 id="1-OpenGL中的摄像机、视景体、近平面"><a href="#1-OpenGL中的摄像机、视景体、近平面" class="headerlink" title="1.OpenGL中的摄像机、视景体、近平面"></a>1.OpenGL中的摄像机、视景体、近平面</h2><p>OpenGL的摄像机和现实世界中的人眼很相似，都有一个三维的坐标表示位置，眼睛的朝向和视野范围，位置和眼睛朝向不同，所观察到的物体的形态就会有所不同，视野范围则规定了只有在该范围的物体才会进入人的视线，超出视野范围的部分就无法被观察到(人总不可能观察到耳朵两边和后脑勺的物体吧。)<br>所以，在OpenGL中的摄像机看来，是这样观察物体的：</p>
<p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/投影1.png" alt=""><br>摄像机视角看近平面：</p>
<p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/视点方向看近平面.png?r=61" alt=""></p>
<p>left、right、bottom、top四条边规定了近平面的大小，near为近平面距离摄像机坐标的距离，far为远平面距离摄像机的距离，这六个变量围成的立方体就是摄像机的可视范围：视景体，物体只有在视景体里面的部分才会被显示出来投影到近平面上。该图为透视投影的案例，投影在近平面的影像会产生近大远小的效果。</p>
<h2 id="2-坐标系"><a href="#2-坐标系" class="headerlink" title="2.坐标系"></a>2.坐标系</h2><h4 id="手机屏幕坐标系"><a href="#手机屏幕坐标系" class="headerlink" title="手机屏幕坐标系"></a>手机屏幕坐标系</h4><p>二维坐标系，左上角为原点，X，Y轴正方向分别为右和下，XY取值范围为屏幕分辨率。</p>
<p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/屏幕坐标系.png?r=49" alt=""></p>
<h4 id="OpenGL世界坐标系"><a href="#OpenGL世界坐标系" class="headerlink" title="OpenGL世界坐标系"></a>OpenGL世界坐标系</h4><p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/世界坐标系.png?r=62" alt=""><br>三维坐标系，X正方向为右，Y正方向为上，Z正方向朝向我们。<br>注意：摄像机位置，投影坐标都是基于世界坐标系设置的。</p>
<h2 id="3-两种投影方式"><a href="#3-两种投影方式" class="headerlink" title="3.两种投影方式"></a>3.两种投影方式</h2><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/正交投影.png?r=82" alt=""></p>
<p><strong>说明：</strong>视点为摄像机的位置；离视点较近，<strong>垂直于观察方向向量</strong>的平面为近平面，离视点较远，<strong>垂直于观察方向向量</strong>的平面为远平面，<br><strong>代码调用</strong>：使用Matrix.orthoM()来设置正交投影。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 生成的投影矩阵,float[4*4]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mOffset 填充时候起始的偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  近平面left边的x坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 近平面right边的x坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bottom  近平面bottom边的y坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> top   近平面top边的y坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> near  近平面距离摄像机的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> far   远平面距离摄像机的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orthoM</span><span class="params">(<span class="keyword">float</span>[] m, <span class="keyword">int</span> mOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p><strong>特点：</strong>透视投影的图已经在上面给出了，它的投影线是不平行的，最终相交于视点处，所以会有近大远小的效果。<br><strong>代码调用</strong>：使用Matrix.frustumM()来设置透视投影。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数含义同正交投影</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frustumM</span><span class="params">(<span class="keyword">float</span>[] m, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perspectiveM</span><span class="params">(<span class="keyword">float</span>[] m, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> zNear, <span class="keyword">float</span> zFar)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="left-right-bottom-top-near-far坐标确定"><a href="#left-right-bottom-top-near-far坐标确定" class="headerlink" title="left,right,bottom,top,near,far坐标确定"></a>left,right,bottom,top,near,far坐标确定</h3><p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/投影坐标系.png" alt=""></p>
<p>红点为摄像机位置(eyeX,eyeY,eyeZ) = (0, 0, 3)。<br>蓝色三角形为被观察的物体（为了方便画图没有用立体图形，但是一个道理，立方体的区别就是顶点z坐标非0了），绿色长方体为视景体，此时三角形全部在视景体内。<br>近平面各坐标：<br>left=-1,right=1,top=2,bottom=-2，<br>近平面z坐标 = eyeZ - near=2，<br>远平面z坐标 = eyeZ - far = -2</p>
<p><strong>near、far的取值范围规定：</strong></p>
<ul>
<li>正交投影时，摄像机可位于视景体中间，此时near &lt; 0，far &gt; 0，近平面位于视点后面（Z轴正方向），远平面位于视点前面（Z轴负方向）</li>
<li>正交投影时，视景体也可位于视点后面(Z轴正方向)，此时near &lt; 0, far &lt; 0</li>
<li>正交投影时，far 和 near没有规定的大小关系，既可以far &gt; near 也可以 far &lt; near，只要物体在视景体内都可以被观察到。</li>
<li>透视投影时，摄像机必须位于视景体前面：eyeZ&gt;近平面Z坐标 &amp;&amp; eyeZ &gt; 远平面Z坐标，即：eyeZ &gt; (eyeZ - near) &amp;&amp; eyeZ &gt;  (eyeZ - far)。</li>
</ul>
<h2 id="4-设置摄像机位置"><a href="#4-设置摄像机位置" class="headerlink" title="4.设置摄像机位置"></a>4.设置摄像机位置</h2><p><strong>代码调用</strong>：使用Matrix.setLookAtM()来设置摄像机位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rm 生成的摄像机矩阵，float[16]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rmOffset 填充时候的起始偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeX 摄像机x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeY 摄像机y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeZ 摄像机z坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerX 观察目标点的x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerY 观察目标点的y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerZ 观察目标点的z坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upX 摄像机up向量在x上的分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upY 摄像机up向量在y上的分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upZ 摄像机up向量在z上的分量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLookAtM</span><span class="params">(<span class="keyword">float</span>[] rm, <span class="keyword">int</span> rmOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> eyeX, <span class="keyword">float</span> eyeY, <span class="keyword">float</span> eyeZ,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> centerZ, <span class="keyword">float</span> upX, <span class="keyword">float</span> upY,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> upZ)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>eyeX,eyeY,eyeZ：</strong>摄像机坐标。<br><strong>centerX,centerY,centerZ:</strong>观察点坐标，和摄像机坐标一起决定了摄像机的观察方向，即向量(centerX - eyeX, centerY - eyeY, centerZ - eyeZ)。观察方向方向不同，</p>
<p><strong>upX,upY,upZ:</strong>摄像机up向量。相对于人眼观察物体中，人头的朝向，头的朝向影响了最后的成像。同样以图来说明：<br><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/up向量为Y轴正方向.png" alt=""><br>当up向量为Y的正方向时，正如我们头顶对着天花板，所以观察到的物体是正的，投影在近平面的样子就是正的，如右图。</p>
<p><img src="/2019/01/24/OpenGL-4-投影和摄像机/[OpenGL] (4) - 投影和摄像机/up方向为X轴正方向.png" alt=""><br>当up向量为X正方向时，正如我们向右90度歪着脑袋去看这个三角形，看到的三角形就会是向左旋转了90度的三角形。<br>再比如up向量如果为Z轴正方向，就相当于仰着头去看这个三角形，但是因为我们的up向量和观察方向平行了，所以我们什么也看不到，就比如仰着头去看你眼前的物体时，你什么也看不到。<br>所以在设置up向量时，一般总是设置为(0,1,0)，这是大多数观察时头朝上的方向。注意：up向量的大小无关紧要，有意义的只有方向。<br>引用一段网上的解释：</p>
<blockquote>
<p>第一组eyex, eyey,eyez 相机在世界搜索坐标的位置<br>第二组centerx,centery,centerz 相机镜头对准的物体在世界坐标的位置<br>第三组upx,upy,upz 相机向上的方向在世界坐标中的方向<br>第一组眼睛就相当于你的头在一个三维坐标中的具体坐标。<br>第二组就是你眼睛要看的物体的坐标。<br>第三组就是你的头的方向。<br>如果你把upx=0;upz=0;upy=1,那么说明你的头是正常人一样的方向，如果upy=-1那么就相当于你是倒立的。<br>如果upx=1;upz=0;upy=0；那么相当于我们看的是右边，如果upx=-1，就相当于看的左边。<br>如果upx=0;upz=1;upy=0；相当于我们看的是屏幕朝我们的方向，如果upz=-1,相当于我们看的是屏幕向里的方向。</p>
</blockquote>
<h2 id="5-变换流程"><a href="#5-变换流程" class="headerlink" title="5.变换流程"></a>5.变换流程</h2><p>一个物体的顶点，是在世界坐标系中被定义的，是怎么样转为为在手机屏幕上显示的坐标的呢，OpenGL中有一系列的变换流程，涉及到了6种不同的空间：<br><strong>物体空间：</strong>物体空间坐标系是在物体的几何中心，相对于物体本身而言的。<br><strong>世界空间：</strong>世界空间一开始有介绍过，是物体在最终的3D场景中的的位置坐标对应的坐标系空间，通过代码设置的物体顶点坐标，摄像机坐标，投影平面的left,right等坐标，都是相对于世界空间的。<br><strong>摄像机空间：</strong>物体经过摄像机观察后，进入摄像机空间，该空间坐标系中，摄像机位于原点，视线沿Z轴负方向，Y轴方向与UP向量一致。<br><strong>剪裁空间：</strong>物体即使被摄像机观察到进入了摄像机空间，如果有的部分位于视景体外部，也是看不到的，所以被摄像机观察到的，同时位于视景体外部的部分裁去，留下在视景体内部的物体部分，这部分构成了剪裁空间。<br><strong>标准设备空间：</strong>将剪裁空间内的物体进行透视除法后得到的就是在标准设备空间的物体，需要注意的是OpenGL中标准设备空间三个轴的坐标范围都是[-1,1]。<br><strong>实际窗口空间：</strong>就是视口，一般使用<code>GLES20.glViewport(int x, int y, int width, int height)</code>设置，通常来说是SurfaceView的大小。</p>
<ul>
<li><p>物体空间-&gt;世界空间<br>乘以物体变换矩阵，比如将三角形先旋转30°再平移(0, 1, 2)，这样按照操作顺序生成的矩阵就是物体的变换矩阵。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//生成变换矩阵</span></span><br><span class="line">    Matrix.setRotateM(mMMartrix, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);    </span><br><span class="line">    Matrix.rotateM(mMMartrix, <span class="number">0</span>, xAngle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>世界空间-&gt;摄像机空间<br>乘以摄像机矩阵。</p>
</li>
<li>摄像机空间-&gt;剪裁空间<br>乘以投影矩阵，乘完后，物体就已经被投影在近平面上了，此时物体各个顶点的坐标不再是三维，而是二维，是对应在近平面上的位置。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入物体变换矩阵,得到最终最终变换矩阵,送入渲染管线</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spec 物体的变换矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span>[] getFinalMatrix(<span class="keyword">float</span>[] spec) &#123;</span><br><span class="line">    mMVPMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line">    Matrix.multiplyMM(mMVPMatrix, <span class="number">0</span>, mCameraMatrix, <span class="number">0</span>, spec, <span class="number">0</span>);    <span class="comment">//乘以摄像机矩阵</span></span><br><span class="line">    Matrix.multiplyMM(mMVPMatrix, <span class="number">0</span>, mProjectionMatrix, <span class="number">0</span>, mMVPMatrix, <span class="number">0</span>);<span class="comment">//乘以投影矩阵</span></span><br><span class="line">    <span class="keyword">return</span> mMVPMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>用户可以操作的为以上三个步骤，一旦物体投影到近平面上后，之后的步骤就由渲染管线自动完成。</code></p>
<ul>
<li>剪裁空间-&gt;标准设备空间<br>经过透视除法，将近平面上的物体顶点坐标化为标准设备空间中[-1,1]坐标。</li>
<li>标准设备空间-&gt;实际窗口空间（视口）<br>将标准设备空间的XY平面[-1,1]的坐标转换为位于实际窗口中的XY像素坐标。</li>
</ul>
<p>在视景体内的物体是先投影到近平面，再到标准设备，最终显示到视口的，所以近平面的宽高非常重要，因为一旦近平面的宽高比出现了问题，那么物体就会被拉伸变形。一般会保持近平面的宽高比和视口的宽高比相等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">//设置视口</span></span><br><span class="line">    <span class="keyword">float</span> ratio = (<span class="keyword">float</span>)width / height;</span><br><span class="line">    MatrixState.setProjectFrustum(-ratio, ratio, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>); </span><br><span class="line">    MatrixState.setCamera(  </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line">            <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">            <span class="number">0f</span>, -<span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，视口大小为width、height，宽高比为ratio，所以设置近平面的<code>left = -ratio, right = ratio, bottom = -1, top = 1</code>，近平面 <code>width = 2ratio, height = 2, width / height = ratio</code>，即为视口宽高比。当然，设置近平面位置也需要考虑需要显示的物体的顶点坐标，如果近平面太小，导致视景体太小无法完全包住观察的物体的话，也就无法观察出来了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/11/深入代码调试原理-server篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/11/深入代码调试原理-server篇/" itemprop="url">深入代码调试原理 - server篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-11T14:33:42+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="深入代码调试原理-server篇"><a href="#深入代码调试原理-server篇" class="headerlink" title="深入代码调试原理-server篇"></a>深入代码调试原理-server篇</h1><p><em>slim</em></p>
<h2 id="1-理解JSCore的Debugger整体架构"><a href="#1-理解JSCore的Debugger整体架构" class="headerlink" title="1.理解JSCore的Debugger整体架构"></a>1.理解JSCore的Debugger整体架构</h2><h3 id="1-1-JSC的Debugger层"><a href="#1-1-JSC的Debugger层" class="headerlink" title="1.1 JSC的Debugger层"></a>1.1 JSC的Debugger层</h3><p>先来看一下JSCore对外提供的Debugger框架：<br><img src="/2019/01/11/深入代码调试原理-server篇/plantuml_jsc_package.png" alt=""></p>
<h4 id="1-1-1-JSC-Debugger-JSC的调试接口"><a href="#1-1-1-JSC-Debugger-JSC的调试接口" class="headerlink" title="1.1.1 JSC::Debugger (JSC的调试接口)"></a>1.1.1 JSC::Debugger (JSC的调试接口)</h4><p>JSCore对外暴露的调试接口，主要用于开发者连接/断开（attach&amp;detach）Debugger、设置断点、通过<code>continue</code> <code>step</code> 对断住的程序进行控制，以及当断点触发后，子类收到的回调方法。</p>
<p><strong>连接</strong>：通过调用<code>attach(JSGlobalObject*)</code>连接到Debugger，让程序具有调试能力。同样也有对应的<code>detach(JSGlobalObject*, ReasonForDetach)</code>方法断开连接。<br><strong>断点</strong>：调用<code>BreakpointID setBreakpoint(Breakpoint&amp;)</code>方法给Debugger设置断点，<code>JSC::Breakpoint</code>有文件的<code>sourceID</code>、行号等信息。<br><img src="/2019/01/11/深入代码调试原理-server篇/plantuml_jsc_breakpoint.png" alt=""></p>
<p><strong>各种调试方法</strong>：<code>continue</code>、<code>stepXXX</code>，都是当断点停下后的调试方法。<br><strong>留给子类实现</strong>：<br><code>sourceParsed(SourceProvider)</code>：当调试程序attach上Debugger后，会传入一个<code>JSGlobalObject</code>，<code>VM</code>会从其中读取到运行的JS文件,进行一个sourceID和文件的匹配，将这些每个文件匹配的结果保存在这个<code>SourceProvider</code>中并分发给子类使用。<br><img src="/2019/01/11/深入代码调试原理-server篇/plantuml_jsc_source_provider.png" alt=""></p>
<p><img src="/2019/01/11/深入代码调试原理-server篇/2019-01-08-16-43-58.png" alt=""></p>
<p><code>handlePause(JSGlobalObject*, ReasonForPause)</code>：程序pause会触发的回调，<code>ReasonForPause</code>说明了pause的原因。<br><code>handleBreakPointHit(JSGlobalObject*,Breakpoint&amp;)</code>:命中断点的回调。如果是命中断点导致程序pause，则上下两个方法都会调用。</p>
<h4 id="1-1-2-Inspector-ScriptDebugServer-（JSC对Debugger的包装）"><a href="#1-1-2-Inspector-ScriptDebugServer-（JSC对Debugger的包装）" class="headerlink" title="1.1.2 Inspector:ScriptDebugServer （JSC对Debugger的包装）"></a>1.1.2 Inspector:ScriptDebugServer （JSC对Debugger的包装）</h4><p>如果不直接继承<code>Debugger</code>，JSCore也提供了<code>ScriptDebugServer</code>这个封装类，该类继承自<code>Debugger</code>，实现了Debugger留给子类的方法，进行了一些处理。并采取注册Listener的形式将这些方法重新dispatch出去，留给开发者实现的<code>ScriptDebugListener</code>接口更加方便好用。</p>
<p><strong>dispatch方法</strong><br><code>dispatchDidParseSource(ListenerSet&amp; listeners, JSC::SourceProvider*)</code>：<code>sourceParsed</code>对应的dispatch方法，该方法会将<code>SourceProvider</code>的JS文件信息都取出来，封装成<code>ScriptDebugListener::Script</code>，最终调用<code>ScriptDebugListener.didParseSource(JSC::SourceID, Script&amp;)</code>给Listener。<br>其余的dispatch方法大都类似，都是回调到Listener的相关接口。</p>
<h3 id="1-2-QG的Debug层"><a href="#1-2-QG的Debug层" class="headerlink" title="1.2 QG的Debug层"></a>1.2 QG的Debug层</h3><p><img src="/2019/01/11/深入代码调试原理-server篇/plantuml_jsdebugger.png" alt=""></p>
<h4 id="1-2-1-JSDebuggerImpl-（QG-Debugger的实现类）"><a href="#1-2-1-JSDebuggerImpl-（QG-Debugger的实现类）" class="headerlink" title="1.2.1 JSDebuggerImpl （QG Debugger的实现类）"></a>1.2.1 JSDebuggerImpl （QG Debugger的实现类）</h4><ul>
<li>同时继承自<code>ScriptDebugServer</code>和<code>ScriptDebugListener</code>，除了重写方法外，对外暴露<code>Attach</code>&amp;<code>Detach</code>接口，将自己<code>addListener</code>到Server中。</li>
<li>JSDebuggerImpl中有一个JSGlobalObject，Debugger的sourceParsed就是用这个取sourceProvider。</li>
<li>将<code>OnBreakpointHit</code>和<code>OnException</code>事件通过<code>JSDebuggerImplHandler</code>通知出去，而<code>JSDebuggerImplHandler</code>的实现类就是<code>JsDebuggerWrapper</code></li>
</ul>
<h4 id="1-2-2-JsDebuggerWrapper-（包装、事件分发）"><a href="#1-2-2-JsDebuggerWrapper-（包装、事件分发）" class="headerlink" title="1.2.2 JsDebuggerWrapper （包装、事件分发）"></a>1.2.2 JsDebuggerWrapper （包装、事件分发）</h4><ul>
<li>包装了<code>JSDebuggerImpl</code></li>
<li>实现<code>JSDebuggerImplHandler</code>接口，并将接口的回调再次通过<code>JsDebuggerWrapperCallback</code>往外分发。<code>JsDebuggerWrapperCallback</code>则是由<code>debugserver</code>创建出来的。</li>
</ul>
<h4 id="1-2-3-debugserver-（通讯）"><a href="#1-2-3-debugserver-（通讯）" class="headerlink" title="1.2.3 debugserver （通讯）"></a>1.2.3 debugserver （通讯）</h4><ul>
<li>包装了<code>JsDebuggerWrapper</code></li>
<li>创建<code>JsDebuggerWrapperCallback</code>监听来自调试器的通知</li>
<li>与调试插件客户端建立<strong>TCP连接</strong>：<ul>
<li>TCP收到来自调试插件端的指令，如<code>step</code>，通过JsDebuggerWrapper -&gt; JSDebuggerImpl -&gt; Debugger 进行指令传递。</li>
<li>收到来自Debugger的事件，如<code>breakpointHit</code>，通过TCP将信息和栈帧数据回给调试方。</li>
</ul>
</li>
</ul>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><h3 id="2-1-startDebug"><a href="#2-1-startDebug" class="headerlink" title="2.1 startDebug"></a>2.1 startDebug</h3><h4 id="2-1-1-在QG-App中进入调试页面启动调试功能"><a href="#2-1-1-在QG-App中进入调试页面启动调试功能" class="headerlink" title="2.1.1 在QG App中进入调试页面启动调试功能"></a>2.1.1 在QG App中进入调试页面启动调试功能</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qg.cpp</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_tencent_qg_sdk_deubgger_Debugger_nativeStartDebugger</span><span class="params">(JNIEnv* env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QGApp::instance()-&gt;getDebuggerHandler()-&gt;startDebugger(QGApp::instance()-&gt;jsGlobalContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-建立TCP连接"><a href="#2-1-2-建立TCP连接" class="headerlink" title="2.1.2 建立TCP连接"></a>2.1.2 建立TCP连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebuggerHandler.cpp</span></span><br><span class="line"><span class="keyword">void</span> DebuggerHandler::startDebugger(<span class="keyword">void</span> *jsGlobalContext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jDebugger)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    jDebugger = JsDebugger::getJDebugger(jsGlobalContext);  <span class="comment">//【★】这里获取到JsDebugger</span></span><br><span class="line">    JsDebugger::JsDebuggerCallback callback;</span><br><span class="line">    callback.accepted = &#123;...&#125;;</span><br><span class="line">    callback.resetJsContext = &#123;...&#125;;</span><br><span class="line">    callback.ready = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】创建回调并Listen住127.0.0.1:9420接口等待插件端接入</span></span><br><span class="line">    jDebugger-&gt;SetCallback(<span class="literal">nullptr</span>, callback);</span><br><span class="line">    jDebugger-&gt;Listen(<span class="string">"127.0.0.1"</span>, <span class="number">9420</span>, INT_MAX, <span class="string">"a.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中我们创建了一个TCP连接，设置好回调，监听端口等待调试方接入。<br>实际上，<code>jDebugger</code>内部调用的就是<code>debugserver.Listen()</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debugserver.cpp</span></span><br><span class="line"><span class="keyword">bool</span> DebugServer::Listen(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;ip, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">uint16_t</span> port, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">int32_t</span> timeout,</span><br><span class="line">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path) &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m_stateMtx);</span><br><span class="line">    <span class="keyword">if</span> (m_state == SERVER_STATE::IDLE &amp;&amp; !path.empty()) &#123;</span><br><span class="line">        m_storagePath = path;</span><br><span class="line">        replace(m_storagePath.begin(), m_storagePath.end(), <span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">bool</span> ret = m_tcpChannel.Listen(ip, port, timeout); <span class="comment">// 【★】 TcpChannel listen</span></span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            m_state = SERVER_STATE::LISTENNING;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-3-握手"><a href="#2-1-3-握手" class="headerlink" title="2.1.3 握手"></a>2.1.3 握手</h4><p>当调试方接入时，debugserver的<code>OnEstablishedHandler</code>将会回调，服务端向调试方发送握手信息(<strong>Aloha</strong>)后，等待调试方的握手信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DebugServer::OnEstablishedHandler() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启消息循环线程</span></span><br><span class="line">    m_senderFuture = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        ServerSenderThread();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tiny::TinyJson params;</span><br><span class="line">    params.put(<span class="string">"sdkVersion"</span> ,<span class="number">1.0</span>);</span><br><span class="line">    params.put(<span class="string">"protocolVersion"</span>,<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">int32_t</span>&gt;(<span class="number">1</span>));</span><br><span class="line">    DomainSchemaSender(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Aloha"</span>), &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pHandler)&#123;</span><br><span class="line">        QGApp::instance()-&gt;runInJsThread([<span class="keyword">this</span>]() &#123;</span><br><span class="line">            m_pHandler-&gt;OnAccepted();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DebugServer::DomainSchemaHandler(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">int32_t</span> id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;command) &#123;</span><br><span class="line">    <span class="keyword">const</span> CodeAndDesc *code = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">"Aloha"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::ESTABLISHED) &#123;</span><br><span class="line">            <span class="comment">// 【★】收到调试方的握手信息，创建Debugger类，传入JSGlobalContext并且setCallback</span></span><br><span class="line">            <span class="keyword">if</span> (m_jsGlobalContext) &#123;</span><br><span class="line">                m_pDebugger = <span class="built_in">std</span>::make_shared&lt;JsDebuggerWrapper&gt;(m_jsGlobalContext);</span><br><span class="line">                JsDebuggerWrapperCallback cb = makeJsDebuggerWrapperCallback();</span><br><span class="line">                m_pDebugger-&gt;SetCallback(<span class="literal">nullptr</span>, cb);</span><br><span class="line">                pthread_mutex_init(&amp;runnableMutex,<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，双方TCP连接已经建立，双方开始进行协议通信。</p>
<h4 id="2-1-4-Run-JS"><a href="#2-1-4-Run-JS" class="headerlink" title="2.1.4 Run JS"></a>2.1.4 Run JS</h4><p>调试方会指定要运行的JS文件列表给到Debugger，Debugger在Native端通过JSCore运行起JS。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DebugServer::DomainApplicationHandler(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">int32_t</span> id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;command,</span><br><span class="line">                                            tiny::TinyJson &amp;params) &#123;</span><br><span class="line">    <span class="keyword">const</span> CodeAndDesc *code = <span class="literal">nullptr</span>;</span><br><span class="line">    tiny::TinyJson result;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">"Run"</span>) &#123;</span><br><span class="line">        NSLog(<span class="string">"Run"</span>);</span><br><span class="line">        <span class="comment">// 【★】协议结构：</span></span><br><span class="line">        <span class="comment">/* &#123;</span></span><br><span class="line"><span class="comment">            "id": 1,</span></span><br><span class="line"><span class="comment">            "domain": "Application",</span></span><br><span class="line"><span class="comment">            "commands": &#123;</span></span><br><span class="line"><span class="comment">                "name": "Run",</span></span><br><span class="line"><span class="comment">                "parameters": &#123;</span></span><br><span class="line"><span class="comment">                "proj_dir":"blabla-game",</span></span><br><span class="line"><span class="comment">                "js":["qg.js","xiaochu/cocos2d-js.js", "xiaochu/src/settings.js", "xiaochu/main.js"]</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        PROJ_DIR = params.Get&lt;<span class="built_in">string</span>&gt;(<span class="string">"proj_dir"</span>);</span><br><span class="line">        tiny::xarray js = params.Get&lt;tiny::xarray&gt;(<span class="string">"js"</span>);</span><br><span class="line">        m_stateMtx.lock();</span><br><span class="line">        m_state = SERVER_STATE::RUNNING;</span><br><span class="line">        m_stateMtx.unlock();</span><br><span class="line">        <span class="keyword">if</span>(m_pHandler)&#123;</span><br><span class="line">              <span class="keyword">if</span>(m_hasRunJs)&#123;</span><br><span class="line">                  <span class="comment">// 【★】已经加载过一次js,所以在此加载之前要重置js context</span></span><br><span class="line">                  m_pHandler-&gt;OnResetJsContext();</span><br><span class="line">                  <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1000</span>ms);</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">int</span> len = js.Count();</span><br><span class="line">            <span class="built_in">string</span>* jsArray = <span class="keyword">new</span> <span class="built_in">string</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; js.Count(); ii++) &#123;</span><br><span class="line">                js.Enter(ii);</span><br><span class="line">                jsArray[ii] = js.Get&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">              QGApp::instance()-&gt;runInJsThread([<span class="keyword">this</span>,jsArray,len]() &#123;</span><br><span class="line">                  <span class="comment">// 【★】通知JSCore运行JS</span></span><br><span class="line">                  <span class="keyword">auto</span> codeAndDesc = m_pHandler-&gt;OnReadyToRun(PROJ_DIR, jsArray,len);</span><br><span class="line">                  m_stateMtx.lock();</span><br><span class="line">                  <span class="keyword">auto</span> code = codeAndDesc.first;</span><br><span class="line">                  <span class="keyword">if</span>(code == <span class="number">200</span>)&#123;</span><br><span class="line">                      m_state = SERVER_STATE::RAN;</span><br><span class="line">                      m_hasRunJs = <span class="literal">true</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                      m_state = SERVER_STATE::ESTABLISHED;</span><br><span class="line">                  &#125;</span><br><span class="line">                  m_stateMtx.unlock();</span><br><span class="line">                  DomainApplicationSender(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Run"</span>), codeAndDesc);</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很简单，主要是在JSON中拿出要运行的JS文件列表和根目录文件夹，最后调用<code>m_pHandler-&gt;OnReadyToRun(PROJ_DIR, jsArray,len)</code>运行JS。</p>
<p><code>OnReadyRun</code>是一个Callback，实现是在<code>DebuggerHandler</code>的<code>callback.ready</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebuggerHandler.cpp</span></span><br><span class="line">callback.ready = [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;proj_dir,</span><br><span class="line">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> js[],<span class="keyword">int</span> len) -&gt; <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="keyword">int16_t</span>, <span class="keyword">const</span> <span class="keyword">char</span> *&gt; &#123;</span><br><span class="line">        <span class="comment">//传递extPath,方便include加载js</span></span><br><span class="line">        <span class="built_in">string</span> jsPath = JsDebugger::DEBUGGER_SDCARD_PATH + proj_dir;</span><br><span class="line">        QGApp::instance()-&gt;setExtResPath(jsPath.data());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; len; ii++) &#123;</span><br><span class="line">            <span class="built_in">string</span> path = jsPath + <span class="string">"/"</span> + js[ii];</span><br><span class="line"></span><br><span class="line">            FILE *f = fopen(path.data(), <span class="string">"r"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!f) &#123;</span><br><span class="line">                NSLog(<span class="string">"Could not open file: %s\n"</span>, path.data());</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="number">503</span>, (<span class="string">"Could not open file:"</span> + path).data()&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            fclose(f);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 【★】是否很熟悉了，调用了QGApp::addJavaScriptFile()加载JS</span></span><br><span class="line">            QGApp::instance()-&gt;addJavaScriptFile(path.data(), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            NSLog(<span class="string">"Debugger load js file:%s"</span>, path.data());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">200</span>, <span class="string">"OK"</span>&#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>QG的<code>addJavaScriptFile(js)</code>会生成<code>LoadJSEvent</code>并放入一个List中，在循环中被拿出来，最终会调用到<code>loadScriptAtPathFromSDCard</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QGApp::loadScriptAtPathFromSDCard(NSString *path, JSContextRef ctx) &#123;</span><br><span class="line">    <span class="comment">// 【★】 参数ctx为QGApp的jsGlobalContext</span></span><br><span class="line">    NSString *scriptPath = pathForResourceFromSDCard(path);</span><br><span class="line">    NSString *script = NSString::createWithContentsOfFile(scriptPath-&gt;getCString());</span><br><span class="line"></span><br><span class="line">    JSStringRef scriptJS = JSStringCreateWithUTF8CString(script-&gt;getCString());</span><br><span class="line">    JSStringRef pathJS = JSStringCreateWithUTF8CString(path-&gt;getCString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】调用JSEvaluateScript启动JSCore加载JS，并和当前上下文绑定。</span></span><br><span class="line">    JSValueRef exception = <span class="literal">NULL</span>;</span><br><span class="line">    JSEvaluateScript(ctx, scriptJS, <span class="literal">NULL</span>, pathJS, <span class="number">0</span>, &amp;exception );</span><br><span class="line">    logException(exception, ctx);</span><br><span class="line"></span><br><span class="line">    JSStringRelease(scriptJS);</span><br><span class="line">    JSStringRelease(pathJS);</span><br><span class="line"></span><br><span class="line">    NS_SAFE_RELEASE_NULL(scriptPath);</span><br><span class="line">    NS_SAFE_RELEASE_NULL(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-5-协议通信"><a href="#2-1-5-协议通信" class="headerlink" title="2.1.5 协议通信"></a>2.1.5 协议通信</h4><p><code>debugserver</code>通过<code>DomainDebuggerHandler</code>接收来自调试方的Commands，包括<code>setBreakPoint</code>、<code>Enabld</code>、<code>Step</code>等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DebugServer::DomainDebuggerHandler(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">int32_t</span> id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;command,</span><br><span class="line">                                        tiny::xarray &amp;params) &#123;</span><br><span class="line">    <span class="keyword">const</span> CodeAndDesc *code = <span class="literal">nullptr</span>;</span><br><span class="line">    tiny::TinyJson result;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">"Enable"</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m_stateMtx);</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::STANDBY || m_state == SERVER_STATE::RUNNING ||</span><br><span class="line">            m_state == SERVER_STATE::RAN</span><br><span class="line">            || m_state == SERVER_STATE::ESTABLISHED) &#123;</span><br><span class="line">            assert(m_pDebugger);<span class="comment">//there must be a debugger instance when STAND BY, see DomainApplicationHandler@Push</span></span><br><span class="line">            <span class="keyword">if</span> (m_pDebugger) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;JsDebuggerWrapper&gt; pDbg = m_pDebugger;</span><br><span class="line">                QGApp::instance()-&gt;runInJsThread([pDbg]() &#123;</span><br><span class="line">                    pDbg-&gt;Attach();</span><br><span class="line">                &#125;);</span><br><span class="line">                code = &amp;CAD_OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                code = &amp;CAD_Internal_Server_Error;</span><br><span class="line">                message = <span class="string">"There is no debugger instance."</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">            message = <span class="string">"Debugger has been enabled."</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">            message = <span class="string">"No Application."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"SetBreakpointByUrl"</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         "parameters":[&#123;"lineNumber": 73, "url": "box.js" &#125;,&#123;"lineNumber": 78, "url": "rotate.js" &#125;]*/</span></span><br><span class="line">        <span class="keyword">bool</span> bOk = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; params.Count(); ii++) &#123;</span><br><span class="line">            params.Enter(ii);</span><br><span class="line">            <span class="keyword">int</span> lineNumber = params.Get&lt;<span class="keyword">int</span>&gt;(<span class="string">"lineNumber"</span>);</span><br><span class="line">            <span class="built_in">string</span> url = params.Get&lt;<span class="built_in">string</span>&gt;(<span class="string">"url"</span>);</span><br><span class="line">            <span class="keyword">if</span> (m_pDebugger)</span><br><span class="line">                bOk = m_pDebugger-&gt;SetBreakpoint(url, lineNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        code = bOk ? &amp;CAD_OK : &amp;CAD_Bad_Request;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"RemoveBreakpointByUrl"</span>) &#123;</span><br><span class="line">        <span class="comment">/*"parameters":[&#123;"lineNumber": 73, "url": "box.js" &#125;,&#123;"lineNumber": 78, "url": "rotate.js" &#125;]*/</span></span><br><span class="line">        <span class="keyword">bool</span> bOk = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; params.Count(); ii++) &#123;</span><br><span class="line">            params.Enter(ii);</span><br><span class="line">            <span class="keyword">int</span> lineNumber = params.Get&lt;<span class="keyword">int</span>&gt;(<span class="string">"lineNumber"</span>);</span><br><span class="line">            <span class="built_in">string</span> url = params.Get&lt;<span class="built_in">string</span>&gt;(<span class="string">"url"</span>);</span><br><span class="line">            <span class="keyword">if</span> (m_pDebugger)</span><br><span class="line">                    bOk = m_pDebugger-&gt;RemoveBreakpoint(url, lineNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        code = bOk ? &amp;CAD_OK : &amp;CAD_Bad_Request;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"StepOver"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line">            m_continueType = JSDEBUGGER_CONTINUE_TYPE::ARKDEBUGGER_STEPOVER;</span><br><span class="line">            m_breakpointCV.notify_one();</span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"StepInto"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line">            m_continueType = JSDEBUGGER_CONTINUE_TYPE::ARKDEBUGGER_STEPINTO;</span><br><span class="line">            m_breakpointCV.notify_one();</span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"StepOut"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line">            m_continueType = JSDEBUGGER_CONTINUE_TYPE::ARKDEBUGGER_STEPOUT;</span><br><span class="line">            m_breakpointCV.notify_one();</span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"Resume"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line">            m_continueType = JSDEBUGGER_CONTINUE_TYPE::DEBUGGER_CONTINUE;</span><br><span class="line">            m_breakpointCV.notify_one();</span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"AttachReady"</span>) &#123;</span><br><span class="line">        m_attachWaitCV.notify_one();</span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line"><span class="comment">//        &#125; else</span></span><br><span class="line"><span class="comment">//            code = &amp;CAD_Not_Acceptable;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"GetProperties"</span>) &#123;</span><br><span class="line">        <span class="comment">/*params:&#123;</span></span><br><span class="line"><span class="comment">         "objectId":[1,2,3]</span></span><br><span class="line"><span class="comment">         &#125;*/</span></span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> paramsString = params.str();</span><br><span class="line"></span><br><span class="line">            runLogicAfterBreakPoint([<span class="keyword">this</span>,id, paramsString]() &#123;</span><br><span class="line">                NSLog(<span class="string">"runLogicAfterBreakPoint paramsString:%s"</span>,paramsString.data());</span><br><span class="line">                xarray paramsArray = tiny::GenerateArray(paramsString);</span><br><span class="line">                tiny::TinyJson rest;</span><br><span class="line">                <span class="keyword">const</span> CodeAndDesc *cde = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; paramsArray.Count(); ii++) &#123;</span><br><span class="line">                    paramsArray.Enter(ii);</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> val = paramsArray.Get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">                    <span class="built_in">string</span> tempStr = m_pMapToValue-&gt;mapGet&lt;<span class="built_in">string</span>&gt;(val);</span><br><span class="line">                    <span class="keyword">if</span>(!tempStr.empty())&#123;</span><br><span class="line">                        tiny::TinyJson temp = m_pMapToValue-&gt;mapGet&lt;tiny::TinyJson&gt;(val);</span><br><span class="line">                        <span class="comment">//对于object类型变量，要去重新请求</span></span><br><span class="line">                        <span class="keyword">if</span> (temp.Get&lt;<span class="built_in">string</span>&gt;(<span class="string">"type"</span>) == <span class="string">"object"</span>) &#123;</span><br><span class="line">                            tiny::xarray varIdTable;</span><br><span class="line">                            <span class="keyword">if</span> (m_pDebugger)</span><br><span class="line">                                m_pDebugger-&gt;analyticJSObject(val, varIdTable);</span><br><span class="line">                            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">                            oss &lt;&lt; <span class="string">",\"value\":"</span> &lt;&lt; varIdTable.str();</span><br><span class="line">                            <span class="built_in">std</span>::<span class="built_in">string</span> value_ = oss.str();</span><br><span class="line">                            <span class="comment">//TinyJson目前不支持读写混合，所以使用这种比较挫的方式拼接结果，有时间一定要改进</span></span><br><span class="line">                            tempStr.insert(tempStr.length()<span class="number">-1</span>,value_);</span><br><span class="line">                        &#125;</span><br><span class="line">                        rest.putStringWithoutQuotes(val, tempStr);</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        rest.putStringWithoutQuotes(val, <span class="string">"&#123;&#125;"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cde = !rest.isEmpty() ? &amp;CAD_OK : &amp;CAD_Bad_Request;</span><br><span class="line">                Reply(id, *cde, rest, msg);</span><br><span class="line"><span class="comment">//                free(copy);</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//将断点唤醒，去取变量</span></span><br><span class="line">            m_breakpointCV.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        code = &amp;CAD_Not_Implemented;</span><br><span class="line">    <span class="keyword">if</span> (code)</span><br><span class="line">        Reply(id, *code, result, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在最主要的就是将<code>JSC::Debugger</code>唤起了，我们先来看<code>Enable</code>命令。</p>
<p><code>Enable</code>主要是在Js主线程调用了<code>JsDebuggerWrapper.Attach()</code>方法，我们已经知道，<code>JsDebuggerWrapper</code>实际上就是<code>JSDebuggerImpl</code>的一个包装，我们直接看后者的Attach做了什么。</p>
<h4 id="2-1-6-Attach-Debugger"><a href="#2-1-6-Attach-Debugger" class="headerlink" title="2.1.6 Attach Debugger"></a>2.1.6 Attach Debugger</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> JSDebuggerImpl::Attach()</span><br><span class="line">&#123;</span><br><span class="line">    addListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，只是调用了<code>addListener(this)</code>将自己加入了Listener列表，通过上文1.1 和 1.2可知，该方法继承自<code>ScriptDebugServer</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScriptDebugServer.cpp</span></span><br><span class="line"><span class="keyword">void</span> ScriptDebugServer::addListener(ScriptDebugListener* listener)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(listener);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = m_listeners.isEmpty();</span><br><span class="line">    m_listeners.add(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First listener. Attach the debugger.</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty)</span><br><span class="line">        attachDebugger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码可见，如果是第一个加入的Listener，会调用<code>attachDebugger</code>，该方法是<code>ScriptDebugServer</code>留给子类实现的（由类图可见），再次看回<code>JSDebuggerImpl</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSDebuggerImpl.cpp</span></span><br><span class="line"><span class="keyword">void</span> JSDebuggerImpl::attachDebugger()</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(<span class="string">"attachDebugger "</span>);</span><br><span class="line">    attach(&amp;m_jsGlobalObject);</span><br><span class="line">    activateBreakpoints();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>JSDebuggerImpl</code>也是<code>JSC::Debugger</code>的子类，所以它直接调用<code>attach</code>正式开启<code>JSC</code>的调试能力。<br>同时，也调用了<code>JSC::Debugger::activateBreakpoints</code>激活所有断点。<br>对了，<code>m_jsGlobalObject</code>从哪里来？在上文2.1.3中，构造<code>JsDebuggerWrapper</code>时传入的<code>JSGlobalContext</code>，会在里面取出<code>JSGlobalObject</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSDebuggerWrapper.cpp</span></span><br><span class="line">JsDebuggerWrapper::JsDebuggerWrapper(<span class="keyword">void</span> *jsGlobalContext) :</span><br><span class="line">    context(<span class="literal">nullptr</span>),</span><br><span class="line">    cb(&#123;<span class="number">0</span>&#125;),</span><br><span class="line">    objContext(<span class="literal">nullptr</span>),</span><br><span class="line"><span class="comment">//            objCb(&#123;0&#125;),</span></span><br><span class="line">    m_pImpl(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    assert(jsGlobalContext);</span><br><span class="line">    <span class="keyword">if</span> (jsGlobalContext) &#123;</span><br><span class="line">        JSGlobalContextRef ctx = <span class="keyword">reinterpret_cast</span>&lt;JSGlobalContextRef&gt;(jsGlobalContext);</span><br><span class="line">        <span class="comment">//【★】构造JSGlobalObject</span></span><br><span class="line">        JSC::JSGlobalObject *pGlobalObject = toJS(ctx)-&gt;vmEntryGlobalObject();</span><br><span class="line">        assert(pGlobalObject);</span><br><span class="line">        <span class="keyword">if</span> (pGlobalObject) &#123;</span><br><span class="line">            <span class="comment">// 【★】使用JSGlobalObject构造JSDebuggerImpl</span></span><br><span class="line">            m_pImpl = <span class="built_in">std</span>::make_shared&lt;JSDebuggerImpl&gt;(*pGlobalObject, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Debugger的attach实现中，拿到QG的JSGlobalObject，会放入自己维护的一份列表中，管理其运行时状态，运行到断点处触发回调。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Debugger.cpp</span></span><br><span class="line"><span class="keyword">void</span> Debugger::attach(JSGlobalObject* globalObject)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!globalObject-&gt;debugger());</span><br><span class="line">    globalObject-&gt;setDebugger(<span class="keyword">this</span>);</span><br><span class="line">    m_globalObjects.add(globalObject);</span><br><span class="line"></span><br><span class="line">    m_vm.setShouldBuildPCToCodeOriginMapping();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call sourceParsed because it will execute JavaScript in the inspector.</span></span><br><span class="line">    <span class="function">GatherSourceProviders <span class="title">gatherSourceProviders</span><span class="params">(globalObject)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">HeapIterationScope <span class="title">iterationScope</span><span class="params">(m_vm.heap)</span></span>;</span><br><span class="line">        m_vm.heap.objectSpace().forEachLiveCell(iterationScope, gatherSourceProviders);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* sourceProvider : gatherSourceProviders.sourceProviders)</span><br><span class="line">        sourceParsed(globalObject-&gt;globalExec(), sourceProvider, <span class="number">-1</span>, String());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-setBreakPoint"><a href="#2-2-setBreakPoint" class="headerlink" title="2.2 setBreakPoint"></a>2.2 setBreakPoint</h3><p>同样，我们在<code>DomainDebuggerHandler</code>找到关于<code>SetBreakpointByUrl</code>的命令，发现最终也是调到了<code>JSDebuggerImpl::SetBreakPointWTF(url, lineNumber)</code>里面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> JSDebuggerImpl::SetBreakpointWTF(<span class="keyword">const</span> String&amp; url, <span class="built_in">std</span>::<span class="keyword">uint32_t</span> lineNumber)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 【★】url为js文件路径，linenumber为断点行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】进行路径模糊匹配</span></span><br><span class="line">    <span class="keyword">auto</span> iter = FuzzyFindFromMap(m_mapSourceUrlToId,url);</span><br><span class="line">    <span class="keyword">if</span> (iter != m_mapSourceUrlToId.end())</span><br><span class="line">    &#123;</span><br><span class="line">        String absoluteUrl = iter-&gt;key;</span><br><span class="line">        <span class="keyword">if</span>(absoluteUrl.contains(url) &amp;&amp; absoluteUrl.length()&gt;url.length())</span><br><span class="line">            jsPath = absoluteUrl.substring(<span class="number">0</span>,absoluteUrl.length()-url.length());</span><br><span class="line"></span><br><span class="line">        --lineNumber;<span class="comment">//jsc line number begins from 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【★】创建JSC::Breakpoint</span></span><br><span class="line">        JSC::Breakpoint bp&#123;iter-&gt;value, lineNumber, <span class="number">0</span>, WTF::String(), <span class="literal">false</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">unsigned</span> actualLine = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> actualColumn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> exist;</span><br><span class="line">        <span class="comment">// 【★】调用JSC::Debugger::setBreakpoint设置断点</span></span><br><span class="line">        JSC::BreakpointID bpId = setBreakpoint(bp, exist);</span><br><span class="line">        <span class="keyword">auto</span> breakpointIDsIterator = m_breakpointMap.find(url);</span><br><span class="line">        <span class="keyword">if</span> (breakpointIDsIterator == m_breakpointMap.end())</span><br><span class="line">            breakpointIDsIterator = m_breakpointMap.<span class="built_in">set</span>(url, <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="keyword">uint32_t</span>, JSC::BreakpointID&gt;()).iterator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【★】将BreakPointID加入Map</span></span><br><span class="line">        <span class="keyword">if</span>(breakpointIDsIterator-&gt;value.find(lineNumber) != breakpointIDsIterator-&gt;value.end())</span><br><span class="line">            breakpointIDsIterator-&gt;value.erase(lineNumber);</span><br><span class="line">        breakpointIDsIterator-&gt;value.emplace(lineNumber, bpId);</span><br><span class="line">        NSLog(<span class="string">"SetBreakpointWTF end"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//set bp before parse source</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> bpMapIter = m_breakpointsCache.find(url);</span><br><span class="line">        <span class="keyword">if</span> (bpMapIter == m_breakpointsCache.end())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            bpMapIter = m_breakpointsCache.<span class="built_in">set</span>(url,<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="keyword">uint32_t</span>&gt;()).iterator;</span><br><span class="line">        &#125;</span><br><span class="line">        bpMapIter-&gt;value.emplace(lineNumber);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟Attah类似，也最终调到了JSC::Debugger中。可以猜想到JSC将这些断点缓存起来，运行到对应断点的行号时，产生回调，代码就不深入看了，接着来看断点回调。</p>
<h3 id="2-3-程序断住（Breaking）"><a href="#2-3-程序断住（Breaking）" class="headerlink" title="2.3 程序断住（Breaking）"></a>2.3 程序断住（Breaking）</h3><p>跟之前由调试方主动发的命令不同，之前是自下而上最终传递到<code>JSCore</code>，现在程序断住应该是<code>JSCore</code> -&gt; 调试方，所以这是一个自上而下的过程。先找到<code>Debugger.handlePause</code>，该方法为程序断住的回调方法。<br>但是在看该方法之前，先来分析一下这个方法是怎么被调用的。<br>该方法的调用链为：<code>updateCallFrame(CallFrame*)</code> - <code>pauseIfNeeded(CallFrame*)</code> - <code>handlePause(vmEntryGlobalObject, m_reasonForPause)</code> </p>
<h4 id="2-3-1-JSC-Debugger栈帧变化（handlePause）"><a href="#2-3-1-JSC-Debugger栈帧变化（handlePause）" class="headerlink" title="2.3.1 JSC::Debugger栈帧变化（handlePause）"></a>2.3.1 JSC::Debugger栈帧变化（handlePause）</h4><p><code>JSC</code>中，如果栈帧发生变化（进\出方法，发生异常等），就会调用<code>updateCallFrame</code>并带上当前栈帧信息和<code>Action</code>，所以<code>updateCallFrame</code>的调用地方有很多的，所以我们将此作为pause的源头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Debugger::updateCallFrame(CallFrame* callFrame, CallFrameUpdateAction action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!callFrame) &#123;</span><br><span class="line">        m_currentCallFrame = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】内部先处理</span></span><br><span class="line">    updateCallFrameInternal(callFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】如果是需要pause的状态，调用pauseIfNeeded</span></span><br><span class="line">    <span class="keyword">if</span> (action == AttemptPause)</span><br><span class="line">        pauseIfNeeded(callFrame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isStepping())</span><br><span class="line">        m_currentCallFrame = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑还是比较清晰，都用【★】标在注释中了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Debugger::pauseIfNeeded(CallFrame* callFrame)</span><br><span class="line">&#123;</span><br><span class="line">    VM&amp; vm = callFrame-&gt;vm();</span><br><span class="line">    <span class="keyword">auto</span> scope = DECLARE_THROW_SCOPE(vm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_isPaused)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_suppressAllPauses)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】先把栈帧的SourceID取出</span></span><br><span class="line">    <span class="keyword">intptr_t</span> sourceID = DebuggerCallFrame::sourceIDForCallFrame(m_currentCallFrame);</span><br><span class="line">    <span class="comment">// 【★】检测是否在黑名单中，如果在就不处理</span></span><br><span class="line">    <span class="keyword">if</span> (isBlacklisted(sourceID))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DebuggerPausedScope <span class="title">debuggerPausedScope</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> pauseNow = m_pauseAtNextOpportunity;</span><br><span class="line">    pauseNow |= (m_pauseOnCallFrame == m_currentCallFrame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> didPauseForStep = pauseNow;</span><br><span class="line">    <span class="keyword">bool</span> didHitBreakpoint = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Breakpoint breakpoint;</span><br><span class="line">    <span class="comment">// 【★】找到当前运行到的文件及代码位置</span></span><br><span class="line">    TextPosition position = DebuggerCallFrame::positionForCallFrame(m_currentCallFrame);</span><br><span class="line">    <span class="comment">// 【★】看一下此处是否有被设置过断点</span></span><br><span class="line">    pauseNow |= didHitBreakpoint = hasBreakpoint(sourceID, position, &amp;breakpoint);</span><br><span class="line">    m_lastExecutedLine = position.m_line.zeroBasedInt();</span><br><span class="line">    <span class="comment">// 【★】如果并没有pause，则直接return</span></span><br><span class="line">    <span class="keyword">if</span> (!pauseNow)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    clearNextPauseState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are not going to pause again on breakpoint actions by</span></span><br><span class="line">    <span class="comment">// reseting the pause state before executing any breakpoint actions.</span></span><br><span class="line">    <span class="function">TemporaryPausedState <span class="title">pausedState</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    JSGlobalObject* vmEntryGlobalObject = callFrame-&gt;vmEntryGlobalObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】如果有被设置断点，则调用handleBreakPointHit通知断点被命中</span></span><br><span class="line">    <span class="keyword">if</span> (didHitBreakpoint) &#123;</span><br><span class="line">        handleBreakpointHit(vmEntryGlobalObject, breakpoint);</span><br><span class="line">        <span class="comment">// Note that the actions can potentially stop the debugger, so we need to check that</span></span><br><span class="line">        <span class="comment">// we still have a current call frame when we get back.</span></span><br><span class="line">        <span class="keyword">if</span> (!m_currentCallFrame)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (breakpoint.autoContinue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!didPauseForStep)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            didHitBreakpoint = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            m_pausingBreakpointID = breakpoint.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】 不管是否命中断点，都会回调handlePause</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">PauseReasonDeclaration <span class="title">reason</span><span class="params">(*<span class="keyword">this</span>, didHitBreakpoint ? PausedForBreakpoint : m_reasonForPause)</span></span>;</span><br><span class="line">        handlePause(vmEntryGlobalObject, m_reasonForPause);</span><br><span class="line">        RELEASE_ASSERT(!scope.exception());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_pausingBreakpointID = noBreakpointID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_pauseAtNextOpportunity &amp;&amp; !m_pauseOnCallFrame) &#123;</span><br><span class="line">        setSteppingMode(SteppingModeDisabled);</span><br><span class="line">        m_currentCallFrame = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-ScriptDebugServer事件分发（Dispatch）"><a href="#2-3-2-ScriptDebugServer事件分发（Dispatch）" class="headerlink" title="2.3.2 ScriptDebugServer事件分发（Dispatch）"></a>2.3.2 ScriptDebugServer事件分发（Dispatch）</h4><p><code>handlePause</code>为<code>Debugger</code>留给子类处理的方法，所以没有实现，但是我们从第一部分可知，<code>Inspector:ScriptDebugServer</code>对其封装了，使用的是Listener的形式，所以自然的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScriptDebugServer.cpp</span></span><br><span class="line"><span class="keyword">void</span> ScriptDebugServer::handlePause(JSGlobalObject* vmEntryGlobalObject, Debugger::ReasonForPause)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 【★】dispatchDidPause给所有ScriptDebugListener</span></span><br><span class="line">    dispatchFunctionToListeners(&amp;ScriptDebugServer::dispatchDidPause);</span><br><span class="line">    didPause(vmEntryGlobalObject);</span><br><span class="line"></span><br><span class="line">    m_doneProcessingDebuggerEvents = <span class="literal">false</span>;</span><br><span class="line">    runEventLoopWhilePaused();</span><br><span class="line"></span><br><span class="line">    didContinue(vmEntryGlobalObject);</span><br><span class="line">    dispatchFunctionToListeners(&amp;ScriptDebugServer::dispatchDidContinue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ScriptDebugServer::dispatchDidPause(ScriptDebugListener* listener)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isPaused());</span><br><span class="line">    DebuggerCallFrame&amp; debuggerCallFrame = currentDebuggerCallFrame();</span><br><span class="line">    JSGlobalObject* globalObject = debuggerCallFrame.scope()-&gt;globalObject();</span><br><span class="line">    <span class="comment">// 【★】从GlobalObject中获取ExecState、Frame</span></span><br><span class="line">    JSC::ExecState&amp; state = *globalObject-&gt;globalExec();</span><br><span class="line">    JSValue jsCallFrame = toJS(&amp;state, globalObject, JavaScriptCallFrame::create(debuggerCallFrame).ptr());</span><br><span class="line">    <span class="comment">// 【★】回调Listener的didPause（状态、栈帧、异常信息）</span></span><br><span class="line">    listener-&gt;didPause(state, jsCallFrame, exceptionOrCaughtValue(&amp;state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JSDebuggerImpl</code>继承自<code>ScriptDebugServer</code>同时实现了<code>ScriptDebugListener</code>，自然也会有<code>didPause</code>方法，终于又回到了QG的Debug层了。</p>
<h4 id="2-3-3-通知调试插件（OnBreakpointHit）"><a href="#2-3-3-通知调试插件（OnBreakpointHit）" class="headerlink" title="2.3.3 通知调试插件（OnBreakpointHit）"></a>2.3.3 通知调试插件（OnBreakpointHit）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSDebuggerImpl::didPause(JSC::ExecState &amp;es, JSC::JSValue callFrames, JSC::JSValue exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pHandler)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pHandler-&gt;ResetSeq();</span><br><span class="line">    &#125;</span><br><span class="line">    tiny::TinyJson stackInfo;</span><br><span class="line">    m_pMapId2Var = <span class="built_in">std</span>::make_shared&lt;tiny::TinyJson&gt;();</span><br><span class="line">    m_varJSValue.clear();</span><br><span class="line">    crossTable.clear();</span><br><span class="line"></span><br><span class="line">    JSContextRef ctx = toRef(&amp;es);</span><br><span class="line">    m_debugCtx = ctx;</span><br><span class="line"></span><br><span class="line">    JSValueRef exceptionValRef = ValueToRef(&amp;es, exception);</span><br><span class="line">    <span class="keyword">if</span> (ctx &amp;&amp; exceptionValRef) &#123;</span><br><span class="line">         <span class="comment">// 【★】如果是因为异常pause，则拿到异常的栈帧信息，保存在exception中。</span></span><br><span class="line">        GetExceptionStackInfo(ctx, exception, exceptionValRef, stackInfo);</span><br><span class="line">        <span class="keyword">if</span> (m_pHandler) &#123;</span><br><span class="line">            <span class="comment">// 【★】回调出去</span></span><br><span class="line">            m_pHandler-&gt;OnException(stackInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【★】普通pause，去拿栈帧信息：ProcessCallFrames</span></span><br><span class="line">    JSValueRef valRef = ValueToRef(&amp;es, callFrames);</span><br><span class="line">    <span class="keyword">if</span> (ctx &amp;&amp; valRef)</span><br><span class="line">    &#123;</span><br><span class="line">        JSValueRef exception = <span class="literal">nullptr</span>;</span><br><span class="line">        JSObjectRef objRef = JSValueToObject(ctx, valRef, &amp;exception);</span><br><span class="line">        <span class="keyword">if</span> (objRef &amp;&amp; !exception)</span><br><span class="line">        &#123;</span><br><span class="line">            ProcessCallFrames(ctx, objRef, stackInfo, *m_pMapId2Var);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】将栈帧信息传出去，并等待OnBreakpointHit返回值，返回值为一个TYPE，标识着调试方在断下来时的操作：continue、stepInto、stepOver、stepOut</span></span><br><span class="line">    <span class="comment">// 并调用相关方法</span></span><br><span class="line">    JSDEBUGGER_CONTINUE_TYPE type = m_pHandler ? m_pHandler-&gt;OnBreakpointHit(stackInfo,m_pMapId2Var) : JSDEBUGGER_CONTINUE_TYPE::DEBUGGER_CONTINUE;</span><br><span class="line">    NSLog(<span class="string">"didPause OnBreakpointHit return JSDEBUGGER_CONTINUE_TYPE = %d"</span>,type);</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> JSDEBUGGER_CONTINUE_TYPE::DEBUGGER_CONTINUE:</span><br><span class="line">            continueProgram();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSDEBUGGER_CONTINUE_TYPE::ARKDEBUGGER_STEPINTO:</span><br><span class="line">            stepIntoStatement();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSDEBUGGER_CONTINUE_TYPE::ARKDEBUGGER_STEPOVER:</span><br><span class="line">            stepOverStatement();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSDEBUGGER_CONTINUE_TYPE::ARKDEBUGGER_STEPOUT:</span><br><span class="line">            stepOutOfFunction();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            continueProgram();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下<code>didPause</code>主要干了两件事：</p>
<ul>
<li>区分是异常断点还是普通断点，异常断点的栈帧信息直接就在<code>Excetion</code>中，直接返回。普通断点则需要通过递归的去取完整的栈帧信息（调用<code>ProcessCallFrames</code>）</li>
<li>普通断点拿到栈帧信息后会回调出去，等待调试方的下一步操作，并调用对应的方法。</li>
</ul>
<p>为什么说会等待呢，就需要看<code>OnBreakpointHit</code>是咋回事了。</p>
<h4 id="2-3-4-等待调试操作（Waiting）"><a href="#2-3-4-等待调试操作（Waiting）" class="headerlink" title="2.3.4 等待调试操作（Waiting）"></a>2.3.4 等待调试操作（Waiting）</h4><p><code>OnBreakpointHit</code>其实就是回调，一层一层往外调并最终调到<code>debugserver</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debugserver.cpp</span></span><br><span class="line">JSDEBUGGER_CONTINUE_TYPE DebugServer::BreakpointHitCallback(tiny::TinyJson &amp;<span class="built_in">stack</span>,</span><br><span class="line">                                                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;tiny::TinyJson&gt; &amp;pMapId2Var) &#123;</span><br><span class="line">    <span class="comment">// 【★】先改变状态，使用锁来确保线程安全性</span></span><br><span class="line">    m_stateMtx.lock();</span><br><span class="line">    SERVER_STATE stateBackup = m_state;</span><br><span class="line">    m_state = SERVER_STATE::BREAKING;</span><br><span class="line">    m_stateMtx.unlock();</span><br><span class="line"></span><br><span class="line">    m_pMapToValue = pMapId2Var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【★】 发送"Paused"命令给调试方，带上栈帧信息，告诉调试方程序已经暂停了</span></span><br><span class="line">    DomainDebuggerSender(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Paused"</span>), &amp;<span class="built_in">stack</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 【★】注意：这里将JS线程wait住了，程序在这里停止</span></span><br><span class="line">        <span class="comment">// 【★】等待m_breakpointCV.notify</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m_breakpointMtx);</span><br><span class="line">        m_breakpointCV.wait(lck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】m_breakpointCV.notify后，才会执行到这里</span></span><br><span class="line">    handleLogicAfterBreakPoint();</span><br><span class="line">    NSLog(<span class="string">"BreakpointHitCallback m_breakpointCV resume "</span>);</span><br><span class="line"></span><br><span class="line">    m_stateMtx.lock();</span><br><span class="line">    <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING)</span><br><span class="line">        m_state = stateBackup;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        assert(m_state == SERVER_STATE::STOPPING ||</span><br><span class="line">               m_state == SERVER_STATE::IDLE);<span class="comment">//stopping while breaking</span></span><br><span class="line">    m_stateMtx.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【★】发送"Resumed"给调试方</span></span><br><span class="line">    DomainDebuggerSender(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Resumed"</span>));</span><br><span class="line">    <span class="comment">// 【★】给上一步返回调试方的操作Type</span></span><br><span class="line">    <span class="keyword">return</span> m_continueType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以见得，当断点回调被传到外面时，会先将栈帧信息发给调试方，然后wait住线程，这时，QGApp上运行的js由于主线程被wait，画面静止，处于调试状态。</strong></p>
<h4 id="2-3-5-调试方发送调试命令（Notify）"><a href="#2-3-5-调试方发送调试命令（Notify）" class="headerlink" title="2.3.5 调试方发送调试命令（Notify）"></a>2.3.5 调试方发送调试命令（Notify）</h4><p>假如此时，用户在调试窗口点击了绿色小箭头，要程序继续执行（关于调试端和Native端事件传输请看<a href="http://km.oa.com/group/25894/articles/show/366328" target="_blank" rel="noopener">代码调试原理 - vscode插件篇</a>），此时同样会调用到<code>debugserver</code>统一的协议处理接口<code>DomainDebuggerHandler</code>，此时的命令为”Resume”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DebugServer::DomainDebuggerHandler(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">int32_t</span> id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;command,</span><br><span class="line">                                        tiny::xarray &amp;params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"Resume"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_state == SERVER_STATE::BREAKING) &#123;</span><br><span class="line">            <span class="comment">// 【★】这里将m_continueType赋值为CONTINUE_TYPE</span></span><br><span class="line">            m_continueType = JSDEBUGGER_CONTINUE_TYPE::DEBUGGER_CONTINUE;</span><br><span class="line">            <span class="comment">// 【★】m_breakpointCV.notify</span></span><br><span class="line">            m_breakpointCV.notify_one();</span><br><span class="line">            code = &amp;CAD_OK;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            code = &amp;CAD_Not_Acceptable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到命令后，赋值<code>m_continueType</code>并<code>notify</code>一气呵成，于是waiting状态被打断，JS程序继续执行，同时2.3.3的代码段会判断<code>m_continueType</code>的值并执行<code>continueProgram()</code>。</p>
<h4 id="2-3-6-程序继续运行（Continue）"><a href="#2-3-6-程序继续运行（Continue）" class="headerlink" title="2.3.6 程序继续运行（Continue）"></a>2.3.6 程序继续运行（Continue）</h4><p><code>continueProgram</code>为<code>JSC::Debugger</code>的方法，JSC会进行内部的状态处理，就跟我们没啥关系了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Debugger::continueProgram()</span><br><span class="line">&#123;</span><br><span class="line">    clearNextPauseState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_isPaused)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    notifyDoneProcessingDebuggerEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-7-其他调试命令（Other-Commands）"><a href="#2-3-7-其他调试命令（Other-Commands）" class="headerlink" title="2.3.7 其他调试命令（Other Commands）"></a>2.3.7 其他调试命令（Other Commands）</h4><p>其他的命令如<code>stepInto</code> <code>StepOver</code> <code>stepOut</code>都是通过类似的逻辑：收到Command -&gt; 改变type -&gt; notify线程 -&gt; 调用Debugger相关方法去实现的，这里就不一一赘述了。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>总的来说，基于JavaScriptCore的调试服务端有以下几点知识是比较重要的：</p>
<ul>
<li>JavaScriptCore对外暴露的调试接口为<code>JSC::Debugger</code>，另外还对其封装了<code>Inspector::ScriptDebugServer</code>和<code>Inspector::ScroptDebugListener</code>，通过继承并实现对应方法，再结合<code>JSC::Debugger</code>提供的调试方法，即可实现一个调试器。</li>
<li>JavaScriptCore是不会帮我们暂停js的执行的，它只负责在程序运行到断点处，或者发生异常时给我们一个回调，由业务方做处理，例如暂停js线程运行，发送数据给调试方展示等。</li>
<li><code>JSC::Debugger</code>面向的是<code>JSGlobalContext</code>和<code>JSGlobalObject</code>，QG Native端运行时会产生唯一的上下文。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/29/深入代码调试原理-vscode篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/29/深入代码调试原理-vscode篇/" itemprop="url">深入代码调试原理 - vscode篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-29T14:57:26+08:00">
                2018-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="深入代码调试原理-QG-VSCode篇"><a href="#深入代码调试原理-QG-VSCode篇" class="headerlink" title="深入代码调试原理-QG VSCode篇"></a>深入代码调试原理-QG VSCode篇</h1><p><em>slim</em></p>
<blockquote>
<p><font size="5"><strong>前言</strong></font><br>Debugger按端大致分为vscode插件端和Server端，插件端主要负责，打开被调试工程，Socket连接Server通信，显示来自Server端的调试数据。Server端主要负责，监听端口等待vscode端连接，并在断点断住的时候传输调试数据给vscode端。</p>
</blockquote>
<h2 id="1-Debugger的整体架构"><a href="#1-Debugger的整体架构" class="headerlink" title="1 Debugger的整体架构"></a>1 Debugger的整体架构</h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a>1.1 基本结构</h3><p><img src="/2018/12/29/深入代码调试原理-vscode篇/debug-extension-api.png" alt=""><br>vscode将整个调试器分为3个角色，<strong>Debugger UI</strong>、<strong>DebugAdapter</strong>、<strong>Debugger</strong>。</p>
<ul>
<li><p><strong>Debugger</strong><br>真正的调试器，掌管程序的状态和控制着程序的执行：<strong>在断点处断住程序</strong>，<strong>获取变量的值</strong>，<strong>获取当前栈帧</strong>，对于调试不同的语言，有不同的实现。比如在JAVA中，该角色就是JAVA虚拟机。在JavaScriptCore中，就是<code>JSC::Debugger</code>。</p>
</li>
<li><p><strong>Vscode Debugger UI</strong><br>vscode提供给开发者的调试界面，用户可以通过UI操作：点击continue、step、查看变量的值，发送命令给DebugAdapter。<br><img src="/2018/12/29/深入代码调试原理-vscode篇/vscode_debugger_ui.png" alt=""></p>
</li>
<li><p><strong>DebugAdapter</strong><br>开发者编写的插件，分别和UI、Debugger通信：</p>
<ul>
<li>接收来自UI的请求，来通知Debugger改变当前程序状态，如：UI收到点击Continue按钮事件后，通知DebugAdapter，后者会和Debugger进行通信，让程序继续跑。</li>
<li>接收来自Debugger的状态变化，取出数据并更新UI，如：断点停下，Debugger主动通知DebugAdapter并带上栈帧数据，DebugAdapter接收到通知后将栈帧数据送给Debugger UI 去显示。</li>
</ul>
</li>
</ul>
<h3 id="1-2-通信协议"><a href="#1-2-通信协议" class="headerlink" title="1.2 通信协议"></a>1.2 通信协议</h3><h4 id="1-2-1-DebugAdapter和Debugger的通信协议"><a href="#1-2-1-DebugAdapter和Debugger的通信协议" class="headerlink" title="1.2.1 DebugAdapter和Debugger的通信协议"></a>1.2.1 DebugAdapter和Debugger的通信协议</h4><p>DebugAdapter和Debugger的通信协议是和Java调试协议（JDWP）类似，所有命令前4个字节为数据长度，紧跟着为具体数据，而数据的格式是JSON。命令体没有JDWP那样复杂。<br><img src="/2018/12/29/深入代码调试原理-vscode篇/JSDWP协议.png" alt=""><br>比如设置断点协议：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"domain"</span>: <span class="string">"Debugger"</span>,</span><br><span class="line">  <span class="attr">"commands"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"SetBreakpointByUrl"</span>,</span><br><span class="line">    <span class="attr">"parameters"</span>: [&#123;</span><br><span class="line">      <span class="attr">"proj_dir"</span>:<span class="string">"blabla-game"</span>,</span><br><span class="line">      <span class="attr">"lineNumber"</span>: <span class="number">73</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"BoxRotate.js"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda3/index.html" target="_blank" rel="noopener">Java调试协议JDWP详解</a></p>
<h4 id="1-2-2-DebugAdapter和vscode-UI的通信协议"><a href="#1-2-2-DebugAdapter和vscode-UI的通信协议" class="headerlink" title="1.2.2 DebugAdapter和vscode UI的通信协议"></a>1.2.2 DebugAdapter和vscode UI的通信协议</h4><p>与vscode ui的通信由vscode规范化的通信协议<code>DebugProtocol</code>定义，里面主要定义了三种数据类型，<code>ProtocolMessage</code>，<code>Arguments</code>，<code>Model</code>。<br><strong>ProtocolMessage</strong>：定义了一套请求-回包(Request - Response)体系：</p>
<pre><code>1. Debugger UI 需要什么数据，就会dispatch具体的Request给DebugAdapter，带上参数（Arguments）。
2. DebugAdapter收到Request，就将数据放入对应Response的body，回复给UI。
3. 如果Adapter需要通知UI状态改变，通过发送Event实现。
</code></pre><p><strong>Arguments</strong>：参数类型，不同Request需要不同的Arguments，统一以XXXArguments命名。<br><strong>Model</strong>：这里的Model其实是vscode对于数据类型的封装，并不是一个统一接口。<br>比如栈帧：<code>StackFrame</code>，断点：<code>BreakPoint</code>，变量：<code>Variable</code><br><img src="/2018/12/29/深入代码调试原理-vscode篇/plantuml_debug_protocol.png" alt=""></p>
<h2 id="2-事件序列"><a href="#2-事件序列" class="headerlink" title="2 事件序列"></a>2 事件序列</h2><p>调试过程中的各种事件通过各种Request - Response - Event进行传递，最开始的调试命令是由用户点击绿色箭头开始的。<br><img src="/2018/12/29/深入代码调试原理-vscode篇/start_debug.png" alt=""><br><img src="/2018/12/29/深入代码调试原理-vscode篇/plantuml_debug_adapter_events.png" alt=""></p>
<h3 id="2-1-初始化（Initialization）"><a href="#2-1-初始化（Initialization）" class="headerlink" title="2.1 初始化（Initialization）"></a>2.1 初始化（Initialization）</h3><p>在初始化阶段，Adapter从收到<code>initializeRequest</code>开始，到<code>send LaunchReponse</code>结束，Adapter和Debugger主要做以下事情。</p>
<ul>
<li><strong>自定义初始化参数</strong><br>在<code>initializeRequest</code>中，自定义<code>InitializeResponse</code>中参数实现定制化，比如：<strong>是否允许setVariable</strong>、<strong>是否允许条件断点</strong>等。</li>
<li><strong>加载根目录配置文件 or 使用默认配置</strong><br><code>LaunchRequestArguments</code>会将调试工程在PC上的路径带过来，而我们则开始在根目录查找是否有配置文件，配置文件可以让开发者配置<strong>qg.js的路径</strong>和<strong>入口js文件路径</strong>，如果没有配置文件，则默认去工程根目录找<strong>qg.js</strong>，默认的入口文件为<strong>index.js</strong>。</li>
<li><strong>建立Socket连接及ADB端口转发</strong><ul>
<li>寻找合适的已连接的设备<br>通过ADB server提供的服务：<code>host:devices</code>获取已连接设备列表，选出合适设备。<br>ADB server的服务请看：<a href="https://android.googlesource.com/platform/system/core/+/jb-dev/adb/SERVICES.TXT" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/jb-dev/adb/SERVICES.TXT</a></li>
<li>端口转发（ADB Forward）<br>因为真正调试的Debugger，也就是JSC::Debugger运行在手机端并Listen了手机端端口A，而DebugAdapter运行在PC端连接上了端口B，如果要进行通信，必须进行端口转发将二者相连。而调用端口转发的方式同样是调用ADB server的服务<code>&lt;host-prefix&gt;:forward:&lt;local&gt;;&lt;remote&gt;</code></li>
<li>Socket连接<br>通过上一步的端口转发，Adapter就可以启动Socket连接到指定手机端口了，socket连接上后会进行握手，握手成功后Socket连接成功。</li>
<li>部署JS &amp; run JS<br>由于需要保证插件和Debugger使用同一份代码，需要将JS工程push到手机SD卡约定的目录下，此处使用命令<code>adb push &lt;localDir&gt; &lt;remoteDir&gt;</code>。并通过协议告诉Debugger</li>
</ul>
</li>
</ul>
<h3 id="2-2-运行（Running）"><a href="#2-2-运行（Running）" class="headerlink" title="2.2 运行（Running）"></a>2.2 运行（Running）</h3><p>在启动成功后，JS工程成功运行，如果有加断点，则会发起<code>SetBreakPointsRequest</code>，该方法的<code>args.breakpoints</code>会带上有断点文件的所有断点信息，例如断点的所在文件的文件名、绝对路径、行数。（如果有多个文件则调用多次，每次调用携带的是一个文件的断点信息），Adapter需要将这些文件名和行号等信息，一一告诉给Debugger就好了。</p>
<h3 id="2-3-程序被断住（Breaking）"><a href="#2-3-程序被断住（Breaking）" class="headerlink" title="2.3 程序被断住（Breaking）"></a>2.3 程序被断住（Breaking）</h3><p>Debugger在拿到全部的断点信息后会缓存起来，当JavaScirptCore运行到断点处时，会断住程序并通知Debugger，Debugger则会将当前的栈帧序列给到Adapter。Adapter则会发送<code>StoppedEvent</code>告诉UI改变状态。UI接着会向Adapter请求需要的信息</p>
<ul>
<li><strong>请求栈帧信息（StackFrames）</strong><br>Debugger在将栈帧信息返回的时候已经包含了栈帧列表，js代码中进入一个方法则该方法压栈，出一个方法则该方法出栈，所以栈帧列表中包含的就是经过的所有方法。Adapter将拿到的栈帧信息编号序号后，返回以<code>DebugProtocol</code>定义的<code>StackFrame</code>结构体数组。<br><img src="/2018/12/29/深入代码调试原理-vscode篇/stack_frames.jpg" alt=""></li>
<li><strong>请求变量范围（Scopes）</strong><br>VscodeUI 拿到栈帧信息后，需要确认每个栈帧的变量有多少范围，如上图所说，通常每个栈帧的变量分为Local和Global，vscode会将这些不同种类的变量分开显示。<br> <img src="/2018/12/29/深入代码调试原理-vscode篇/scopes.jpg" alt=""></li>
<li><strong>请求变量的值（Variable）</strong><br>当鼠标点击展开某个变量时，vscode会将这个变量的id通过<code>variablesRequestArgument</code>带下来，Adapter会向Debugger请求该变量的信息。vscode将变量分为<strong>可展开</strong> 和 <strong>不可展开</strong>的，可展开的变量说明是一个Object，不可展开的变量说明只是一个基本数据类型。Adapter拿到变量的值后将其以<code>DebugProtocol</code>定义的<code>Variable</code>形式返回。</li>
</ul>
<h3 id="2-4-调试阶段（Debugging）"><a href="#2-4-调试阶段（Debugging）" class="headerlink" title="2.4 调试阶段（Debugging）"></a>2.4 调试阶段（Debugging）</h3><p>程序一旦被断下来，UI更新后，vscode就进入了调试模式，vscode提供了很多入口供开发者操作，开发者通过鼠标点击来触发对应的Request。<br><img src="/2018/12/29/深入代码调试原理-vscode篇/debugging.jpg" alt=""></p>
<h3 id="2-5-断开调试（Disconnect）"><a href="#2-5-断开调试（Disconnect）" class="headerlink" title="2.5 断开调试（Disconnect）"></a>2.5 断开调试（Disconnect）</h3><p>开发者点击stop按钮断开调试，与初始化模式相反，该阶段需要告诉Debugger调试程序已经退出、断开ADB和Socket等操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/ListView开发中遇到的坑及源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/ListView开发中遇到的坑及源码分析/" itemprop="url">ListView开发中遇到的坑及源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T23:49:25+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h2 id="ListView开发中遇到的坑及源码分析"><a href="#ListView开发中遇到的坑及源码分析" class="headerlink" title="ListView开发中遇到的坑及源码分析"></a>ListView开发中遇到的坑及源码分析</h2><h3 id="1、起因"><a href="#1、起因" class="headerlink" title="1、起因"></a>1、起因</h3><p>之前在需求开发的时候碰到过一个坑，出于某种原因，在Adapter的getView()方法中不能使用xml的资源，只能new出一个View，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">     TextView textView = <span class="keyword">new</span> TextView(mContext);</span><br><span class="line">     LinearLayout.LayoutParams params = <span class="keyword">new</span> LinearLayout.LayoutParams(</span><br><span class="line">             ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">     textView.setLayoutParams(params);</span><br><span class="line">     <span class="keyword">return</span> textView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这时需要的是给这个View设置LayoutParams，在之前的概念中对这个LayoutParams的类型没有直接的要求，一般是看需求使用LinearLayout.LayoutParams或者RelativeLayout.LayoutParams，然后设置给View后就返回了。然后一段时间的平安无事后，测试突然丢了段crash日志给我，图我找不到了，但是第一行就是：LinearLayout.LayoutParams cannot cast to AbsListView.LayoutParams：</p>
<p>可以看出这是类型转换异常，但是我拿到这个日志后就很奇怪，因为在我的测试机上不会有问题，而在测试的机子上这是必现crash，我想应该是API版本问题，我的测试机是API 21以上的，而测试的机型是Kitkat（API 19），于是我直接分析API 19 的源码。</p>
<h3 id="2、跟踪源码（API-19）"><a href="#2、跟踪源码（API-19）" class="headerlink" title="2、跟踪源码（API 19）"></a>2、跟踪源码（API 19）</h3><p>我们知道，View的绘制机制是onMeasure()-&gt;onLayout()-&gt;onDraw()，这种类型转换异常肯定是在Measure的步骤就发生了的，毕竟Measure的时候肯定得使用LayoutParams的，于是跟踪进ListView的onMeasure方法中看它做了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> childWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据我们继承的Adapter的getCount()方法得到一共有多少个Child</span></span><br><span class="line">    mItemCount = mAdapter == <span class="keyword">null</span> ? <span class="number">0</span> : mAdapter.getCount();</span><br><span class="line">    <span class="keyword">if</span> (mItemCount &gt; <span class="number">0</span> &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED ||</span><br><span class="line">            heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        <span class="comment">// 这里通过obtainView()拿到childView</span></span><br><span class="line">        <span class="keyword">final</span> View child = obtainView(<span class="number">0</span>, mIsScrap);</span><br><span class="line">		<span class="comment">// 去测量该childView --- crash的地点！</span></span><br><span class="line">        measureScrapChild(child, <span class="number">0</span>, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省略根据widthMode 和 heightMode 计算 widthSize 和 heightSize 的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(widthSize , heightSize);</span><br><span class="line">    mWidthMeasureSpec = widthMeasureSpec;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onMeasure()方法根据obtainView()拿到每一个childView后，会紧接着调用measureScrapChild(child)去测量，我们继续跟进这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureScrapChild</span><span class="params">(View child, <span class="keyword">int</span> position, <span class="keyword">int</span> widthMeasureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 取出ChildView的LayoutParams进行强转，试图转成AbsListView.LayoutParams，就是这里发生了crash</span></span><br><span class="line">    LayoutParams p = (LayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = (AbsListView.LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">        child.setLayoutParams(p);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    p.forceAdd = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    </span><br><span class="line">    child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就找到了原因，ListView认为它所有的子View的LayoutParams都必须是AbsListView.LayoutParams类型的，如果是通过inflate xml文件得到的View，会自动设置上AbsListView.LayoutParams，但是通过代码new出来的View，如果不亲自设置，就会在源码中出现类型转换的crash。</p>
<h3 id="3、解决问题（多种方案）"><a href="#3、解决问题（多种方案）" class="headerlink" title="3、解决问题（多种方案）"></a>3、解决问题（多种方案）</h3><p><strong>第一种方案：</strong><br>最推荐的也是最简单的处理方法当然是在Adapter的getView中不随便使用LayoutParams而必须使用AbsListView.LayoutParams，这样保证不会出现crash，如果需要new多个View就给他们的Parent设置该LayoutParams并返回parent：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">     TextView textView = <span class="keyword">new</span> TextView(mContext);</span><br><span class="line">     AbsListView.LayoutParams params = <span class="keyword">new</span> AbsListView.LayoutParams(</span><br><span class="line">             ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">     textView.setLayoutParams(params);</span><br><span class="line">     <span class="keyword">return</span> textView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第二种方案：</strong><br>在老版本中，如果很任性，就是不按照第一种方案来，而是想搞个大新闻的话，有没有其他的方案呢？答案当然是有的，我们继续分析源码，上面提到过，ListView根据obtainView()去获取childView，那么跟进obtainView()中去看下它做了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span>[] isScrap)</span> </span>&#123;</span><br><span class="line">     Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"obtainView"</span>);</span><br><span class="line"></span><br><span class="line">     isScrap[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">     View scrapView;</span><br><span class="line"></span><br><span class="line">     scrapView = mRecycler.getTransientStateView(position);</span><br><span class="line">     <span class="keyword">if</span> (scrapView == <span class="keyword">null</span>) &#123;</span><br><span class="line">         scrapView = mRecycler.getScrapView(position);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     View child;</span><br><span class="line">	 <span class="comment">// 调用Adapter.getView()拿到childView</span></span><br><span class="line">     <span class="keyword">if</span> (scrapView != <span class="keyword">null</span>) &#123;</span><br><span class="line">         child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);</span><br><span class="line">         <span class="comment">// 省略...</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         child = mAdapter.getView(position, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">         <span class="comment">// 省略...</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果mAdapterHasStableIds为true，则进入该分支</span></span><br><span class="line">     <span class="keyword">if</span> (mAdapterHasStableIds) &#123;</span><br><span class="line">	     <span class="comment">// 拿到child的LayoutParams</span></span><br><span class="line">         <span class="keyword">final</span> ViewGroup.LayoutParams vlp = child.getLayoutParams();</span><br><span class="line">         LayoutParams lp;</span><br><span class="line">         <span class="keyword">if</span> (vlp == <span class="keyword">null</span>) &#123;</span><br><span class="line">             lp = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!checkLayoutParams(vlp)) &#123;</span><br><span class="line">	         <span class="comment">// 如果拿到的LayoutParams不是AbsListView.LayoutParams，则给它包装成AbsListView.LayoutParams</span></span><br><span class="line">             lp = (LayoutParams) generateLayoutParams(vlp);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             lp = (LayoutParams) vlp;</span><br><span class="line">         &#125;</span><br><span class="line">         lp.itemId = mAdapter.getItemId(position);</span><br><span class="line">         child.setLayoutParams(lp);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//省略...</span></span><br><span class="line">     <span class="keyword">return</span> child;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查是否为AbsListView.LayoutParams</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> AbsListView.LayoutParams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装为AbsListView.LayoutParams</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单，看注释就可以了。那么，很急很关键的是：mAdapterHasStableIds是个啥，它什么时候为true？很明显只要mAdapterHasStableIds==true，系统就会通过这个if分支对我们的LayoutParams进行保护处理，这样即使Adapter.getView中返回的View不是AbsListView.LayoutParams，也不会crash。<br>mAdapterHasStableIds是个啥，我们从ListView.setAdapter()开始看起：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用了AbsListView.setAdapter    </span></span><br><span class="line">	<span class="keyword">super</span>.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbsListView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 原来就是我们继承的Adapter的hasStableIds()的返回值！</span></span><br><span class="line">        mAdapterHasStableIds = mAdapter.hasStableIds();</span><br><span class="line">        <span class="keyword">if</span> (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mAdapterHasStableIds &amp;&amp;</span><br><span class="line">                mCheckedIdStates == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCheckedIdStates = <span class="keyword">new</span> LongSparseArray&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就很清楚了，我们写Adapter的时候，总会重写两个重要的方法：getCount()，getView()，但是Adapter还提供其他的方法的重写，比如getItemId()和hasStableIds()。所以想要解决这个crash，只要在Adapter的hasStableIds()返回true就搞定了。</p>
<p><strong>但是，总得告诉我为什么吧？</strong></p>
<h3 id="4、知其然，更知其所以然"><a href="#4、知其然，更知其所以然" class="headerlink" title="4、知其然，更知其所以然"></a>4、知其然，更知其所以然</h3><p>至于Adapter的hasStableIds()的方法到底起到什么样的作用，引用一段来自StackOverFlow的回答：</p>
<blockquote>
<p>Stable IDs allow the ListView to optimize for the case when items remain the same between notifyDataSetChanged calls. The IDs it refers to are the ones returned from getItemId.</p>
</blockquote>
<blockquote>
<p>Without it, the ListView has to recreate all Views since it can’t know if the item IDs are the same between data changes (e.g. if the ID is just the index in the data, it has to recreate everything). With it, it can refrain from recreating Views that kept their item IDs.</p>
</blockquote>
<p>好了我知道你们没耐心翻译，简单来说就是：<strong>如果hasStableIds()返回了true，那么在调用notifyDataSetChanged刷新界面时，决定重绘每个ItemView之前，会调用Adapter.getItemId(int position)方法拿到该Item的新的id，和之前老的id对比，如果没有变化，则认为这个Item的数据没有变化，UI也不会发生变化，则不会Recreate这个ItemView，达到优化性能的目的。</strong></p>
<p>所以hasStableIds()方法需要和getItemId()配合使用，那么到底在getItemId中返回什么样的数才能标识该Item的数据没有变化呢？在大部分情况下，返回这个Item对应的Model的hashCode就好了，用hashCode来标识数据有没有发生变化，在下面的例子中，如果一个Student的id和name不发生变化，则认为该Item数据没变化，不用重绘UI：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StudentAdapter.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	    Student student = mStudents.get(position);</span><br><span class="line">	    <span class="keyword">return</span> student.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStableIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Student student = (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != student.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(student.name) : student.name == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们重写Adapter时，不是只有getCount和getView方法重要，其他的方法也同样重要，以后如果允许的话，请不要简单的在getItemId()方法中返回position哦！</p>
<h3 id="5、继续跟踪源码（API-21）"><a href="#5、继续跟踪源码（API-21）" class="headerlink" title="5、继续跟踪源码（API 21）"></a>5、继续跟踪源码（API 21）</h3><p>还遗留了最后一个问题，那么为啥在我的测试机(API 21)上不会出现crash呢，肯定是Android源码在新版本上进行了修改，同样去看AbsListView的obtainView()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span>[] outMetadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View scrapView = mRecycler.getScrapView(position);</span><br><span class="line">    <span class="keyword">final</span> View child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 省略... </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里会设置ChildView的LayoutParams</span></span><br><span class="line">    setItemViewLayoutParams(child, position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很容易看到的是，比起老版本，新版本代码多了一个setItemViewLayoutParams方法，只要调用obtainView就会进入这个方法里面，不会再有if条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的ChildView都会通过这个方法设置LayoutParams，经过这层保护逻辑后，全部的LayoutParams都是AbsListView.LayoutParams类型拉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setItemViewLayoutParams</span><span class="params">(View child, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams vlp = child.getLayoutParams();</span><br><span class="line">    LayoutParams lp;</span><br><span class="line">    <span class="keyword">if</span> (vlp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lp = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!checkLayoutParams(vlp)) &#123;</span><br><span class="line">        lp = (LayoutParams) generateLayoutParams(vlp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lp = (LayoutParams) vlp;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 其实还是会判断hasStableIds，只不过这里将ItemId直接赋值到LayoutParams里去了。</span></span><br><span class="line">    <span class="keyword">if</span> (mAdapterHasStableIds) &#123;</span><br><span class="line">        lp.itemId = mAdapter.getItemId(position);</span><br><span class="line">    &#125;</span><br><span class="line">    lp.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    lp.isEnabled = mAdapter.isEnabled(position);</span><br><span class="line">    <span class="keyword">if</span> (lp != vlp) &#123;</span><br><span class="line">      child.setLayoutParams(lp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这就是API &gt;= 21不会出现Crash的原因啦！</strong> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/" itemprop="url">OpenGL(5) - 实现一个能自由移动的摄像机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T17:53:37+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="实现一个能自由移动的摄像机"><a href="#实现一个能自由移动的摄像机" class="headerlink" title="实现一个能自由移动的摄像机"></a>实现一个能自由移动的摄像机</h1><h2 id="摄像机矩阵（观察矩阵）"><a href="#摄像机矩阵（观察矩阵）" class="headerlink" title="摄像机矩阵（观察矩阵）"></a>摄像机矩阵（观察矩阵）</h2><p>对OpenGL有基本概念的同学应该都知道，为了将物体的自己的坐标转换为手机屏幕上的坐标，需要经过几个空间的变换。</p>
<ul>
<li><strong>局部空间（或者被称为物体控件）</strong><br>  在该空间下，所有的坐标都是相对于自身而言，坐标系原点可能位于物体中心。</li>
<li><strong>世界空间</strong><br>  我们在世界空间里指定了一个原点，通过<strong>模型矩阵</strong>，将局部空间中的坐标转换到世界坐标，俗话说就是将我们的物体摆在世界中，这时物体的坐标就是相对于世界坐标系原点的坐标。</li>
<li><strong>观察空间</strong><br>   使用<strong>观察矩阵</strong>将对象的世界空间的坐标转换为观察者视野前面的坐标。因此观察空间就是从摄像机的角度观察到的空间。这个观察矩阵与摄像机的位置，方向，角度有关。</li>
<li><strong>裁剪空间</strong><br>  使用<strong>投影矩阵</strong>将顶点坐标从观察空间转换到裁剪空间。裁剪空间定义为：以照相机的角度来看，规定一个可视范围，在可视范围之外的点就不显示，在可视范围内的点，投影矩阵会将其坐标转换为标准化设备坐标系中（-1, 1）。</li>
<li><strong>屏幕空间</strong><br>  将上一步得到的所有在标准化设备坐标系中的点，映射到手机屏幕的坐标中，比如手机是800 * 1280，在标准化设备坐标系中的点A（0.5,1），就会落在手机屏幕的（400,1280）上。</li>
</ul>
<p>对于摄像机来说，建立一个观察矩阵，需要几个重要的向量。<br><strong>1.摄像机位置</strong><br>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中代表摄像机位置的向量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector postion = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 将摄像机摆在Z轴正方向3的位置</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.摄像机方向</strong><br>定义一个front向量，标识摄像机看向的方向，例如(0, 0, -1)就是表示摄像机朝着Z负方向观察，(0, 1, 0)表示朝着Y轴正方向观察，（0, 1, -1）表示在ZY平面朝45度角仰望悲伤。这里我们摄像机在Z轴上，让它朝着Z轴负方向看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector front = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>有了pos和front，就可以计算出摄像机看向的点的位置pos + front，就是（0, 0, 2）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector target = postion + front = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>然后就可以计算出摄像机的方向向量direct<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector direct = position - target = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>可以发现，摄像机的方向向量比较奇怪，它不是指向target的向量，而是从target指向摄像机的向量，不要问我为什么因为我也不知道</strong></p>
<p><strong>3.右轴（Right）</strong><br>我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：定义一个上向量(Up Vector)。我们把上向量和第二步得到的摄像机方向向量进行叉乘。两个向量叉乘的结果就是同时垂直于两向量的向量，因此我们会得到指向x轴正方向的那个向量(如果我们交换两个向量的顺序就会得到相反的指向x轴负方向的向量)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector worldUp = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);   <span class="comment">// 世界坐标系的up向量，永远为Y轴正方向</span></span><br><span class="line">Vector right = Vector.cross(direct, worldUp);</span><br></pre></td></tr></table></figure></p>
<p><strong>4.上轴（Up）</strong><br>现在已经有了right 和 direct向量，分别对应摄像机坐标系的X正轴和Z轴，获取摄像机的up向量也很简单：通过叉乘实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector up = Vector.cross(direct, right);</span><br></pre></td></tr></table></figure></p>
<p>经过上述一系列操作，就得出了已摄像机为原点的坐标系，有了right direct up 向量就可以创建LookAt矩阵了。</p>
<p><img src="/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/2018-10-31-17-19-06.jpg" alt=""></p>
<h2 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h2><blockquote>
<p>使用矩阵的好处之一是如果你定义了一个坐标空间，里面有3个相互垂直的轴，你可以用这三个轴外加一个平移向量来创建一个矩阵，你可以用这个矩阵乘以任何向量来变换到那个坐标空间。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：<br> <img src="/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/2018-10-31-17-24-14.jpg" alt=""><br>R是右向量，U是上向量，D是方向向量P是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。使用这个LookAt矩阵坐标观察矩阵可以很高效地把所有世界坐标变换为观察坐标LookAt矩阵就像它的名字表达的那样：它会创建一个观察矩阵looks at(看着)一个给定目标。</p>
</blockquote>
<p><strong>当然，上面的看不懂就算了，项目开发中不用我们自己去计算LookAt矩阵，Matrix提供了方法可以很方便的获得LookAt矩阵。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rm 生成的摄像机矩阵，float[16]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rmOffset 填充时候的起始偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeX 摄像机x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeY 摄像机y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeZ 摄像机z坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerX 观察目标点的x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerY 观察目标点的y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerZ 观察目标点的z坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upX 摄像机up向量在x上的分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upY 摄像机up向量在y上的分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upZ 摄像机up向量在z上的分量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLookAtM</span><span class="params">(<span class="keyword">float</span>[] rm, <span class="keyword">int</span> rmOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> eyeX, <span class="keyword">float</span> eyeY, <span class="keyword">float</span> eyeZ,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> centerZ, <span class="keyword">float</span> upX, <span class="keyword">float</span> upY,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> upZ)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经通过上述操作得到了一系列摄像机向量，就可以传入这个方法得到摄像机矩阵了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> viewMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line">Matrix.setIdentityM(viewMatrix, <span class="number">0</span>);</span><br><span class="line">Matrix.setLookAtM(viewMatrix, <span class="number">0</span>,</span><br><span class="line">    position.x, position.y, position.z,</span><br><span class="line">    position.x + front.x, position.y + front.y, position.z + front.z,</span><br><span class="line">    up.x, up.y, up.z);</span><br></pre></td></tr></table></figure></p>
<h2 id="应用我们的摄像机"><a href="#应用我们的摄像机" class="headerlink" title="应用我们的摄像机"></a>应用我们的摄像机</h2><p><strong>摄像机类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GLCamera</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 摄像机的4个关键向量</span></span><br><span class="line">    <span class="keyword">private</span> Vector position;</span><br><span class="line">    <span class="keyword">private</span> Vector front;</span><br><span class="line">    <span class="keyword">private</span> Vector up;</span><br><span class="line">    <span class="keyword">private</span> Vector right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 世界坐标系的up，计算right向量用</span></span><br><span class="line"><span class="comment">     * 默认的世界up为(0, 1, 0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Vector worldUp = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GLCamera</span><span class="params">(Vector position, Vector up, Vector front)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">        <span class="keyword">this</span>.front = front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GLCamera</span><span class="params">(Vector position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(position, <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>[] getViewMatrix() &#123;</span><br><span class="line">        updateCameraVectors();</span><br><span class="line">        Matrix.setIdentityM(viewMatrix, <span class="number">0</span>);</span><br><span class="line">        Matrix.setLookAtM(viewMatrix, <span class="number">0</span>,</span><br><span class="line">            position.x, position.y, position.z,</span><br><span class="line">            position.x + front.x, position.y + front.y, position.z + front.z,</span><br><span class="line">            up.x, up.y, up.z);</span><br><span class="line">        <span class="keyword">return</span> viewMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        front = Vector.normalize(front);</span><br><span class="line">        Vector direct = <span class="keyword">new</span> Vector(-front.x, -front.y, -front.z);   <span class="comment">// 还记得吗，direct的方向和front方向相反</span></span><br><span class="line">        right = Vector.normalize(Vector.cross(direct, worldUp));</span><br><span class="line">        up = Vector.normalize(Vector.cross(right, direct));</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>GLSurfaceView类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraGLSurfaceView</span> <span class="keyword">extends</span> <span class="title">GLSurfaceView</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] VERTEX_ARRAY = &#123;</span><br><span class="line">            <span class="comment">// 位置顶点    // 纹理顶点</span></span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector[] CUBE_POSITIONS = &#123;</span><br><span class="line">            <span class="keyword">new</span> Vector(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, -<span class="number">15.0f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(-<span class="number">1.5f</span>, -<span class="number">2.2f</span>, -<span class="number">2.5f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(-<span class="number">3.8f</span>, -<span class="number">2.0f</span>, -<span class="number">12.3f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(<span class="number">2.4f</span>, -<span class="number">0.4f</span>, -<span class="number">3.5f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(-<span class="number">1.7f</span>,  <span class="number">3.0f</span>, -<span class="number">7.5f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(<span class="number">1.3f</span>, -<span class="number">2.0f</span>, -<span class="number">2.5f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, -<span class="number">2.5f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, -<span class="number">1.5f</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector(-<span class="number">1.3f</span>,  <span class="number">1.0f</span>, -<span class="number">1.5f</span>)</span><br><span class="line">    &#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer mVertexBuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String VERTEX_SHADER =</span><br><span class="line">            <span class="string">"#version 300 es \n"</span> +</span><br><span class="line">                    <span class="string">"layout (location = 0) in vec3 pos; \n"</span> +</span><br><span class="line">                    <span class="string">"layout (location = 1) in vec2 texPos; \n"</span> +</span><br><span class="line">                    <span class="string">"uniform mat4 model; \n"</span> +</span><br><span class="line">                    <span class="string">"uniform mat4 view; \n"</span> +</span><br><span class="line">                    <span class="string">"uniform mat4 projection; \n"</span> +</span><br><span class="line">                    <span class="string">"out vec2 f_texPos; \n"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123; \n"</span> +</span><br><span class="line">                    <span class="string">"   gl_Position = projection * view * model * vec4(pos, 1); \n"</span> +</span><br><span class="line">                    <span class="string">"   f_texPos = texPos; \n"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FRAGMENT_SHADER =</span><br><span class="line">            <span class="string">"#version 300 es \n"</span> +</span><br><span class="line">                    <span class="string">"precision mediump float; \n"</span> +</span><br><span class="line">                    <span class="string">"in vec2 f_texPos; \n"</span> +</span><br><span class="line">                    <span class="string">"uniform sampler2D texture1; \n"</span> +</span><br><span class="line">                    <span class="string">"uniform sampler2D texture2; \n"</span> +</span><br><span class="line">                    <span class="string">"out vec4 color; \n"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123; \n"</span> +</span><br><span class="line">                    <span class="string">"   color = mix(texture(texture1, f_texPos), texture(texture2, f_texPos), 0.2); \n"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProgram;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mPosHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTexPosHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mModelMatrixHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mViewMatrixHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProjectionHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mTex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTexture1Handle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTexture2Handle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> VAO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mModelMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];   <span class="comment">// 模型矩阵</span></span><br><span class="line"><span class="comment">//    private float[] mViewMatrix = new float[16];    // 观察矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mProjectionMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];    <span class="comment">// 投影矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GLCamera mCamera ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            mHandler.sendEmptyMessageDelayed(<span class="number">1</span>, <span class="number">16</span>);</span><br><span class="line">            requestRender();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraGLSurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraGLSurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mVertexBuf = array2FloatBuffer(VERTEX_ARRAY);</span><br><span class="line">        setEGLContextClientVersion(<span class="number">3</span>);</span><br><span class="line">        setRenderer(<span class="keyword">this</span>);</span><br><span class="line">        setRenderMode(RENDERMODE_WHEN_DIRTY);</span><br><span class="line"></span><br><span class="line">        mCamera = <span class="keyword">new</span> GLCamera(<span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>)); <span class="comment">// 摄像机在0, 0, 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FloatBuffer <span class="title">array2FloatBuffer</span><span class="params">(<span class="keyword">float</span>[] array)</span> </span>&#123;</span><br><span class="line">        FloatBuffer floatBuffer = ByteBuffer.allocateDirect(array.length * <span class="number">4</span>)</span><br><span class="line">                .order(ByteOrder.nativeOrder())</span><br><span class="line">                .asFloatBuffer()</span><br><span class="line">                .put(array);</span><br><span class="line">        floatBuffer.position(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> floatBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">        GLES30.glEnable(GLES30.GL_DEPTH_TEST);</span><br><span class="line">        GLES30.glClearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT | GLES30.GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        mProgram = GLUtil.createProgram(VERTEX_SHADER, FRAGMENT_SHADER);</span><br><span class="line">        <span class="keyword">if</span> (mProgram &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"create program error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPosHandle = GLES30.glGetAttribLocation(mProgram, <span class="string">"pos"</span>);</span><br><span class="line">        mTexPosHandle = GLES30.glGetAttribLocation(mProgram, <span class="string">"texPos"</span>);</span><br><span class="line">        mModelMatrixHandle = GLES30.glGetUniformLocation(mProgram, <span class="string">"model"</span>);</span><br><span class="line">        mViewMatrixHandle = GLES30.glGetUniformLocation(mProgram, <span class="string">"view"</span>);</span><br><span class="line">        mProjectionHandle = GLES30.glGetUniformLocation(mProgram, <span class="string">"projection"</span>);</span><br><span class="line">        mTexture1Handle = GLES30.glGetUniformLocation(mProgram, <span class="string">"texture1"</span>);</span><br><span class="line">        mTexture2Handle = GLES30.glGetUniformLocation(mProgram, <span class="string">"texture2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] vaos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES30.glGenVertexArrays(<span class="number">1</span>, vaos, <span class="number">0</span>);</span><br><span class="line">        VAO = vaos[<span class="number">0</span>];</span><br><span class="line">        GLES30.glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] vbos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES30.glGenBuffers(<span class="number">1</span>, vbos, <span class="number">0</span>);</span><br><span class="line">        GLES30.glBindBuffer(GLES30.GL_ARRAY_BUFFER, vbos[<span class="number">0</span>]);</span><br><span class="line">        GLES30.glBufferData(GLES30.GL_ARRAY_BUFFER, mVertexBuf.capacity() * <span class="number">4</span>, mVertexBuf, GLES30.GL_STATIC_DRAW);</span><br><span class="line">        GLES30.glVertexAttribPointer(mPosHandle, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">5</span> * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        GLES30.glVertexAttribPointer(mTexPosHandle, <span class="number">2</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">5</span> * <span class="number">4</span>, <span class="number">3</span> * <span class="number">4</span>);</span><br><span class="line">        GLES30.glEnableVertexAttribArray(mPosHandle);</span><br><span class="line">        GLES30.glEnableVertexAttribArray(mTexPosHandle);</span><br><span class="line">        GLES30.glBindBuffer(GLES30.GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        GLES30.glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建两个纹理id</span></span><br><span class="line">        GLES30.glGenTextures(<span class="number">2</span>, mTex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一个纹理</span></span><br><span class="line">        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, mTex[<span class="number">0</span>]);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_S, GLES30.GL_MIRRORED_REPEAT);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_T, GLES30.GL_MIRRORED_REPEAT);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);</span><br><span class="line">        GLUtils.texImage2D(GLES30.GL_TEXTURE_2D, <span class="number">0</span>, BitmapFactory.decodeResource(getResources(), R.drawable.wall), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第二个纹理</span></span><br><span class="line">        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, mTex[<span class="number">1</span>]);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_S, GLES30.GL_MIRRORED_REPEAT);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_T, GLES30.GL_MIRRORED_REPEAT);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);</span><br><span class="line">        GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);</span><br><span class="line">        GLUtils.texImage2D(GLES30.GL_TEXTURE_2D, <span class="number">0</span>, BitmapFactory.decodeResource(getResources(), R.drawable.awesomeface), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        mWidth = width;</span><br><span class="line">        mHeight = height;</span><br><span class="line">        GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">        mHandler.sendEmptyMessageDelayed(<span class="number">1</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GLES30.glClearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT | GLES30.GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        GLES30.glUseProgram(mProgram);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个纹理id 对应纹理单元0</span></span><br><span class="line">        GLES30.glActiveTexture(GLES30.GL_TEXTURE0);</span><br><span class="line">        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, mTex[<span class="number">0</span>]);</span><br><span class="line">        GLES30.glUniform1i(mTexture1Handle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个纹理id 对应纹理单元1</span></span><br><span class="line">        GLES30.glActiveTexture(GLES30.GL_TEXTURE1);</span><br><span class="line">        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, mTex[<span class="number">1</span>]);</span><br><span class="line">        GLES30.glUniform1i(mTexture2Handle, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置观察矩阵(摄像机矩阵)</span></span><br><span class="line">        GLES30.glUniformMatrix4fv(mViewMatrixHandle, <span class="number">1</span>, <span class="keyword">false</span>, mCamera.getViewMatrix(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置投影矩阵</span></span><br><span class="line">        Matrix.setIdentityM(mProjectionMatrix, <span class="number">0</span>);</span><br><span class="line">        Matrix.perspectiveM(mProjectionMatrix, <span class="number">0</span>, <span class="number">45</span>, (<span class="keyword">float</span>)mWidth / mHeight, <span class="number">0.1f</span>, <span class="number">100f</span>);</span><br><span class="line">        GLES30.glUniformMatrix4fv(mProjectionHandle, <span class="number">1</span>, <span class="keyword">false</span>, mProjectionMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VAO</span></span><br><span class="line">        GLES30.glBindVertexArray(VAO);</span><br><span class="line">        <span class="comment">// 这里重复调用10次draw画10个正方体，每个正方体的模型矩阵都不同，所以需要每次都计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; CUBE_POSITIONS.length;i++) &#123;</span><br><span class="line">            <span class="comment">// 设置模型矩阵</span></span><br><span class="line">            Matrix.setIdentityM(mModelMatrix, <span class="number">0</span>);</span><br><span class="line">            Matrix.translateM(mModelMatrix, <span class="number">0</span>, CUBE_POSITIONS[i].x, CUBE_POSITIONS[i].y, CUBE_POSITIONS[i].z);</span><br><span class="line">            Matrix.rotateM(mModelMatrix, <span class="number">0</span>, i * <span class="number">20f</span>, <span class="number">1f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>);</span><br><span class="line">            GLES30.glUniformMatrix4fv(mModelMatrixHandle, <span class="number">1</span>, <span class="keyword">false</span>, mModelMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            GLES30.glDrawArrays(GLES30.GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        GLES30.glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Vector类</strong><br>Android中貌似没有一个表示向量的类，于是自己搞了一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = vector.x;</span><br><span class="line">        <span class="keyword">this</span>.y = vector.y;</span><br><span class="line">        <span class="keyword">this</span>.z = vector.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 俩向量的叉乘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = a.y * b.z - a.z * b.y;</span><br><span class="line">        <span class="keyword">float</span> y = a.z * b.x - a.x * b.z;</span><br><span class="line">        <span class="keyword">float</span> z = a.x * b.y - a.y * b.x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准化向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="title">normalize</span><span class="params">(Vector v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);   <span class="comment">// 向量的模</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(v.x / (<span class="keyword">float</span>)length, v.y / (<span class="keyword">float</span>)length, v.z / (<span class="keyword">float</span>)length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>叉乘</strong></p>
<blockquote>
<p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子：</p>
</blockquote>
<p><img src="/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/2018-10-31-17-51-52.jpg" alt=""></p>
<p><img src="/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/2018-10-31-20-02-12.jpg" alt=""></p>
<h2 id="让摄像机动起来"><a href="#让摄像机动起来" class="headerlink" title="让摄像机动起来"></a>让摄像机动起来</h2><h3 id="让摄像机平移"><a href="#让摄像机平移" class="headerlink" title="让摄像机平移"></a>让摄像机平移</h3><p>想象一下你们在玩第一人称游戏时，是怎么移动人物的，是通过<strong>WASD</strong>是吗，分别对应：<br>W - 向前移动<br>S - 向后移动<br>A - 向左移动<br>D - 向右移动<br>但是其实如果人物可以有上天遁地的功能的话，其实还会有<strong>向上移动</strong>和<strong>向下移动</strong>，人物做不到，但是摄像机可以做到</p>
<p><strong>我们先定义一组方向枚举，表示 前进、后退、上、下、左、右</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    FORWARD, BACKWARD, LEFT, RIGHT, UP, DOWN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>然后定义一个方法，处理来自外部的移动</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processKeyboardMovement</span><span class="params">(Direction direction, <span class="keyword">float</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (direction == Direction.FORWARD) &#123;</span><br><span class="line">        position.x += front.x * offset;</span><br><span class="line">        position.y += front.y * offset;</span><br><span class="line">        position.z += front.z * offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(direction == Direction.BACKWARD) &#123;</span><br><span class="line">        position.x -= front.x * offset;</span><br><span class="line">        position.y -= front.y * offset;</span><br><span class="line">        position.z -= front.z * offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(direction == Direction.LEFT) &#123;</span><br><span class="line">        Vector crossVector = Vector.normalize(Vector.cross(front, up));</span><br><span class="line">        position.x -= crossVector.x * offset;</span><br><span class="line">        position.y -= crossVector.y * offset;</span><br><span class="line">        position.z -= crossVector.z * offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(direction == Direction.RIGHT) &#123;</span><br><span class="line">        Vector crossVector = Vector.normalize(Vector.cross(front, up));</span><br><span class="line">        position.x += crossVector.x * offset;</span><br><span class="line">        position.y += crossVector.y * offset;</span><br><span class="line">        position.z += crossVector.z * offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == Direction.UP) &#123;</span><br><span class="line">        position.x += up.x * offset;</span><br><span class="line">        position.y += up.y * offset;</span><br><span class="line">        position.z += up.z * offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == Direction.DOWN) &#123;</span><br><span class="line">        position.x -= up.x * offset;</span><br><span class="line">        position.y -= up.y * offset;</span><br><span class="line">        position.z -= up.z * offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法接受两个参数，一个是方向，一个是距离，前后移动是以front方向为移动方向移动，左右是以front和up的叉乘向量，也就是right向量，上下则是up向量。<br>然后让距离乘以移动向量的各个分量，加到对应position向量上去就好了。</p>
<p><strong>Important：为什么是移动方向向量直接乘offset，会不会导致距离不对？</strong><br>还记的<code>updateCameraVectors</code>方法，我们对于front up right向量都执行了标准化向量（<strong>normalize</strong>）操作，标准向量就是长度为1的向量，用标准化向量的各个分量乘以移动距离，得到的自然就是在各个分量上需要移动的距离。</p>
<p><strong>最后，在Activity加上6个按钮，表示往6个方向移动。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goForward</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGLSurfaceView.mCamera.processKeyboardMovement(GLCamera.Direction.FORWARD, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backUp</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGLSurfaceView.mCamera.processKeyboardMovement(GLCamera.Direction.BACKWARD, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goLeft</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGLSurfaceView.mCamera.processKeyboardMovement(GLCamera.Direction.LEFT, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goRight</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGLSurfaceView.mCamera.processKeyboardMovement(GLCamera.Direction.RIGHT, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span> <span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGLSurfaceView.mCamera.processKeyboardMovement(GLCamera.Direction.UP, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span> <span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGLSurfaceView.mCamera.processKeyboardMovement(GLCamera.Direction.DOWN, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="让摄像机移动视角（变换front方向）"><a href="#让摄像机移动视角（变换front方向）" class="headerlink" title="让摄像机移动视角（变换front方向）"></a>让摄像机移动视角（变换front方向）</h3><p>（写不动了，下次写吧…..）</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2017/10/31/OpenGL-5-实现一个能自由移动的摄像机/ScreenRecord_2018-10-31-19-31-57.gif" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/OpenGL-4-投影和摄像机/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/OpenGL-4-投影和摄像机/" itemprop="url">OpenGL(4) - 投影和摄像机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T17:53:37+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="OpenGL入门-4-投影和摄像机"><a href="#OpenGL入门-4-投影和摄像机" class="headerlink" title="OpenGL入门(4) - 投影和摄像机"></a>OpenGL入门(4) - 投影和摄像机</h1><h2 id="1-OpenGL中的摄像机、视景体、近平面"><a href="#1-OpenGL中的摄像机、视景体、近平面" class="headerlink" title="1.OpenGL中的摄像机、视景体、近平面"></a>1.OpenGL中的摄像机、视景体、近平面</h2><p>OpenGL的摄像机和现实世界中的人眼很相似，都有一个三维的坐标表示位置，眼睛的朝向和视野范围，位置和眼睛朝向不同，所观察到的物体的形态就会有所不同，视野范围则规定了只有在该范围的物体才会进入人的视线，超出视野范围的部分就无法被观察到(人总不可能观察到耳朵两边和后脑勺的物体吧。)<br>所以，在OpenGL中的摄像机看来，是这样观察物体的：</p>
<p><img src="/2017/10/24/OpenGL-4-投影和摄像机/投影1.png" alt=""><br>摄像机视角看近平面：</p>
<p><img src="/2017/10/24/OpenGL-4-投影和摄像机/视点方向看近平面.png?r=61" alt=""></p>
<p>left、right、bottom、top四条边规定了近平面的大小，near为近平面距离摄像机坐标的距离，far为远平面距离摄像机的距离，这六个变量围成的立方体就是摄像机的可视范围：视景体，物体只有在视景体里面的部分才会被显示出来投影到近平面上。该图为透视投影的案例，投影在近平面的影像会产生近大远小的效果。</p>
<h2 id="2-坐标系"><a href="#2-坐标系" class="headerlink" title="2.坐标系"></a>2.坐标系</h2><h4 id="手机屏幕坐标系"><a href="#手机屏幕坐标系" class="headerlink" title="手机屏幕坐标系"></a>手机屏幕坐标系</h4><p>二维坐标系，左上角为原点，X，Y轴正方向分别为右和下，XY取值范围为屏幕分辨率。</p>
<p><img src="/2017/10/24/OpenGL-4-投影和摄像机/屏幕坐标系.png?r=49" alt=""></p>
<h4 id="OpenGL世界坐标系"><a href="#OpenGL世界坐标系" class="headerlink" title="OpenGL世界坐标系"></a>OpenGL世界坐标系</h4><p><img src="/2017/10/24/OpenGL-4-投影和摄像机/世界坐标系.png?r=62" alt=""><br>三维坐标系，X正方向为右，Y正方向为上，Z正方向朝向我们。<br>注意：摄像机位置，投影坐标都是基于世界坐标系设置的。</p>
<h2 id="3-两种投影方式"><a href="#3-两种投影方式" class="headerlink" title="3.两种投影方式"></a>3.两种投影方式</h2><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img src="/2017/10/24/OpenGL-4-投影和摄像机/正交投影.png?r=82" alt=""></p>
<p><strong>说明：</strong>视点为摄像机的位置；离视点较近，<strong>垂直于观察方向向量</strong>的平面为近平面，离视点较远，<strong>垂直于观察方向向量</strong>的平面为远平面，<br><strong>代码调用</strong>：使用Matrix.orthoM()来设置正交投影。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 生成的投影矩阵,float[4*4]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mOffset 填充时候起始的偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  近平面left边的x坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 近平面right边的x坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bottom  近平面bottom边的y坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> top   近平面top边的y坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> near  近平面距离摄像机的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> far   远平面距离摄像机的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orthoM</span><span class="params">(<span class="keyword">float</span>[] m, <span class="keyword">int</span> mOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p><strong>特点：</strong>透视投影的图已经在上面给出了，它的投影线是不平行的，最终相交于视点处，所以会有近大远小的效果。<br><strong>代码调用</strong>：使用Matrix.frustumM()来设置透视投影。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数含义同正交投影</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frustumM</span><span class="params">(<span class="keyword">float</span>[] m, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perspectiveM</span><span class="params">(<span class="keyword">float</span>[] m, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> zNear, <span class="keyword">float</span> zFar)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="left-right-bottom-top-near-far坐标确定"><a href="#left-right-bottom-top-near-far坐标确定" class="headerlink" title="left,right,bottom,top,near,far坐标确定"></a>left,right,bottom,top,near,far坐标确定</h3><p><img src="/2017/10/24/OpenGL-4-投影和摄像机/投影坐标系.png" alt=""></p>
<p>红点为摄像机位置(eyeX,eyeY,eyeZ) = (0, 0, 3)。<br>蓝色三角形为被观察的物体（为了方便画图没有用立体图形，但是一个道理，立方体的区别就是顶点z坐标非0了），绿色长方体为视景体，此时三角形全部在视景体内。<br>近平面各坐标：<br>left=-1,right=1,top=2,bottom=-2，<br>近平面z坐标 = eyeZ - near=2，<br>远平面z坐标 = eyeZ - far = -2</p>
<p><strong>near、far的取值范围规定：</strong></p>
<ul>
<li>正交投影时，摄像机可位于视景体中间，此时near &lt; 0，far &gt; 0，近平面位于视点后面（Z轴正方向），远平面位于视点前面（Z轴负方向）</li>
<li>正交投影时，视景体也可位于视点后面(Z轴正方向)，此时near &lt; 0, far &lt; 0</li>
<li>正交投影时，far 和 near没有规定的大小关系，既可以far &gt; near 也可以 far &lt; near，只要物体在视景体内都可以被观察到。</li>
<li>透视投影时，摄像机必须位于视景体前面：eyeZ&gt;近平面Z坐标 &amp;&amp; eyeZ &gt; 远平面Z坐标，即：eyeZ &gt; (eyeZ - near) &amp;&amp; eyeZ &gt;  (eyeZ - far)。</li>
</ul>
<h2 id="4-设置摄像机位置"><a href="#4-设置摄像机位置" class="headerlink" title="4.设置摄像机位置"></a>4.设置摄像机位置</h2><p><strong>代码调用</strong>：使用Matrix.setLookAtM()来设置摄像机位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rm 生成的摄像机矩阵，float[16]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rmOffset 填充时候的起始偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeX 摄像机x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeY 摄像机y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eyeZ 摄像机z坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerX 观察目标点的x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerY 观察目标点的y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> centerZ 观察目标点的z坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upX 摄像机up向量在x上的分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upY 摄像机up向量在y上的分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upZ 摄像机up向量在z上的分量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLookAtM</span><span class="params">(<span class="keyword">float</span>[] rm, <span class="keyword">int</span> rmOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> eyeX, <span class="keyword">float</span> eyeY, <span class="keyword">float</span> eyeZ,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> centerZ, <span class="keyword">float</span> upX, <span class="keyword">float</span> upY,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> upZ)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>eyeX,eyeY,eyeZ：</strong>摄像机坐标。<br><strong>centerX,centerY,centerZ:</strong>观察点坐标，和摄像机坐标一起决定了摄像机的观察方向，即向量(centerX - eyeX, centerY - eyeY, centerZ - eyeZ)。观察方向方向不同，</p>
<p><strong>upX,upY,upZ:</strong>摄像机up向量。相对于人眼观察物体中，人头的朝向，头的朝向影响了最后的成像。同样以图来说明：<br><img src="/2017/10/24/OpenGL-4-投影和摄像机/up向量为Y轴正方向.png" alt=""><br>当up向量为Y的正方向时，正如我们头顶对着天花板，所以观察到的物体是正的，投影在近平面的样子就是正的，如右图。</p>
<p><img src="/2017/10/24/OpenGL-4-投影和摄像机/up方向为X轴正方向.png" alt=""><br>当up向量为X正方向时，正如我们向右90度歪着脑袋去看这个三角形，看到的三角形就会是向左旋转了90度的三角形。<br>再比如up向量如果为Z轴正方向，就相当于仰着头去看这个三角形，但是因为我们的up向量和观察方向平行了，所以我们什么也看不到，就比如仰着头去看你眼前的物体时，你什么也看不到。<br>所以在设置up向量时，一般总是设置为(0,1,0)，这是大多数观察时头朝上的方向。注意：up向量的大小无关紧要，有意义的只有方向。<br>引用一段网上的解释：</p>
<blockquote>
<p>第一组eyex, eyey,eyez 相机在世界搜索坐标的位置<br>第二组centerx,centery,centerz 相机镜头对准的物体在世界坐标的位置<br>第三组upx,upy,upz 相机向上的方向在世界坐标中的方向<br>第一组眼睛就相当于你的头在一个三维坐标中的具体坐标。<br>第二组就是你眼睛要看的物体的坐标。<br>第三组就是你的头的方向。<br>如果你把upx=0;upz=0;upy=1,那么说明你的头是正常人一样的方向，如果upy=-1那么就相当于你是倒立的。<br>如果upx=1;upz=0;upy=0；那么相当于我们看的是右边，如果upx=-1，就相当于看的左边。<br>如果upx=0;upz=1;upy=0；相当于我们看的是屏幕朝我们的方向，如果upz=-1,相当于我们看的是屏幕向里的方向。</p>
</blockquote>
<h2 id="5-变换流程"><a href="#5-变换流程" class="headerlink" title="5.变换流程"></a>5.变换流程</h2><p>一个物体的顶点，是在世界坐标系中被定义的，是怎么样转为为在手机屏幕上显示的坐标的呢，OpenGL中有一系列的变换流程，涉及到了6种不同的空间：<br><strong>物体空间：</strong>物体空间坐标系是在物体的几何中心，相对于物体本身而言的。<br><strong>世界空间：</strong>世界空间一开始有介绍过，是物体在最终的3D场景中的的位置坐标对应的坐标系空间，通过代码设置的物体顶点坐标，摄像机坐标，投影平面的left,right等坐标，都是相对于世界空间的。<br><strong>摄像机空间：</strong>物体经过摄像机观察后，进入摄像机空间，该空间坐标系中，摄像机位于原点，视线沿Z轴负方向，Y轴方向与UP向量一致。<br><strong>剪裁空间：</strong>物体即使被摄像机观察到进入了摄像机空间，如果有的部分位于视景体外部，也是看不到的，所以被摄像机观察到的，同时位于视景体外部的部分裁去，留下在视景体内部的物体部分，这部分构成了剪裁空间。<br><strong>标准设备空间：</strong>将剪裁空间内的物体进行透视除法后得到的就是在标准设备空间的物体，需要注意的是OpenGL中标准设备空间三个轴的坐标范围都是[-1,1]。<br><strong>实际窗口空间：</strong>就是视口，一般使用<code>GLES20.glViewport(int x, int y, int width, int height)</code>设置，通常来说是SurfaceView的大小。</p>
<ul>
<li><p>物体空间-&gt;世界空间<br>乘以物体变换矩阵，比如将三角形先旋转30°再平移(0, 1, 2)，这样按照操作顺序生成的矩阵就是物体的变换矩阵。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//生成变换矩阵</span></span><br><span class="line">    Matrix.setRotateM(mMMartrix, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);    </span><br><span class="line">    Matrix.rotateM(mMMartrix, <span class="number">0</span>, xAngle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>世界空间-&gt;摄像机空间<br>乘以摄像机矩阵。</p>
</li>
<li>摄像机空间-&gt;剪裁空间<br>乘以投影矩阵，乘完后，物体就已经被投影在近平面上了，此时物体各个顶点的坐标不再是三维，而是二维，是对应在近平面上的位置。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入物体变换矩阵,得到最终最终变换矩阵,送入渲染管线</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spec 物体的变换矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span>[] getFinalMatrix(<span class="keyword">float</span>[] spec) &#123;</span><br><span class="line">    mMVPMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line">    Matrix.multiplyMM(mMVPMatrix, <span class="number">0</span>, mCameraMatrix, <span class="number">0</span>, spec, <span class="number">0</span>);    <span class="comment">//乘以摄像机矩阵</span></span><br><span class="line">    Matrix.multiplyMM(mMVPMatrix, <span class="number">0</span>, mProjectionMatrix, <span class="number">0</span>, mMVPMatrix, <span class="number">0</span>);<span class="comment">//乘以投影矩阵</span></span><br><span class="line">    <span class="keyword">return</span> mMVPMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>用户可以操作的为以上三个步骤，一旦物体投影到近平面上后，之后的步骤就由渲染管线自动完成。</code></p>
<ul>
<li>剪裁空间-&gt;标准设备空间<br>经过透视除法，将近平面上的物体顶点坐标化为标准设备空间中[-1,1]坐标。</li>
<li>标准设备空间-&gt;实际窗口空间（视口）<br>将标准设备空间的XY平面[-1,1]的坐标转换为位于实际窗口中的XY像素坐标。</li>
</ul>
<p>在视景体内的物体是先投影到近平面，再到标准设备，最终显示到视口的，所以近平面的宽高非常重要，因为一旦近平面的宽高比出现了问题，那么物体就会被拉伸变形。一般会保持近平面的宽高比和视口的宽高比相等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">//设置视口</span></span><br><span class="line">    <span class="keyword">float</span> ratio = (<span class="keyword">float</span>)width / height;</span><br><span class="line">    MatrixState.setProjectFrustum(-ratio, ratio, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>); </span><br><span class="line">    MatrixState.setCamera(  </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line">            <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">            <span class="number">0f</span>, -<span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，视口大小为width、height，宽高比为ratio，所以设置近平面的<code>left = -ratio, right = ratio, bottom = -1, top = 1</code>，近平面 <code>width = 2ratio, height = 2, width / height = ratio</code>，即为视口宽高比。当然，设置近平面位置也需要考虑需要显示的物体的顶点坐标，如果近平面太小，导致视景体太小无法完全包住观察的物体的话，也就无法观察出来了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/OpenGL-3-OpenGL's Hello World/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/OpenGL-3-OpenGL's Hello World/" itemprop="url">OpenGL(3) - OpenGL's Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-15T17:50:36+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="OpenGL-3-OpenGL’s-Hello-World"><a href="#OpenGL-3-OpenGL’s-Hello-World" class="headerlink" title="OpenGL(3) - OpenGL’s Hello World"></a>OpenGL(3) - OpenGL’s Hello World</h1><h3 id="1-编写GLSL程序"><a href="#1-编写GLSL程序" class="headerlink" title="1.编写GLSL程序"></a>1.编写GLSL程序</h3><p>着色器是通过glsl语言编写的，各个平台统一，实现了一次编写，到处使用。在Android中，glsl程序一般有两种书写方式：</p>
<ul>
<li><p>单独写成文件，放在/app/assets/ 文件夹下，后缀名为glsl，在代码中通过Resource读取内容。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uMVPMatrix;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> aColor;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> vColor;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = uMVPMatrix * <span class="type">vec4</span>(aPosition, <span class="number">1</span>);</span><br><span class="line">    vColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代码中通过字符串拼接生成final的shader代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String VERTEX_SHADER_CODE =</span><br><span class="line">          <span class="string">"uniform mat4 uMVPMatrix;\n"</span> +</span><br><span class="line">          <span class="string">"attribute vec3 aPosition;\n"</span> +</span><br><span class="line">          <span class="string">"attribute vec2 aTexturePos;\n"</span> +  <span class="comment">//传给顶点着色器的纹理坐标</span></span><br><span class="line">          <span class="string">"varying vec2 vTexturePos;\n"</span> +     <span class="comment">//传给片元着色器的纹理坐标</span></span><br><span class="line">          <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">          <span class="string">"    gl_Position = uMVPMatrix * vec4(aPosition, 1);\n"</span> +</span><br><span class="line">          <span class="string">"    vTexturePos = aTexturePos;\n"</span> +</span><br><span class="line">          <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-创建着色器程序的工具类"><a href="#2-创建着色器程序的工具类" class="headerlink" title="2.创建着色器程序的工具类"></a>2.创建着色器程序的工具类</h3><p>通用方法，写成工具类。一般在GLSurfaceView的onCreate中或者在可以被draw的Model类中调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShaderUtil.java</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建着色器程序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexSource 顶点着色器源代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentSource 片元着色器源代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 程序id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">createProgram</span><span class="params">(String vertexSource, String fragmentSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载顶点着色器和片元着色器</span></span><br><span class="line">        <span class="keyword">int</span> vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);</span><br><span class="line">        <span class="keyword">if</span>(vertexShader == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);</span><br><span class="line">        <span class="keyword">if</span>(fragmentShader == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建着色器程序并attach着色器</span></span><br><span class="line">        <span class="keyword">int</span> program = GLES20.glCreateProgram(); </span><br><span class="line">        <span class="keyword">if</span>(program != <span class="number">0</span>) &#123;</span><br><span class="line">            GLES20.glAttachShader(program, vertexShader);</span><br><span class="line">            checkGlError(<span class="string">"glAttachShader"</span>);</span><br><span class="line">            GLES20.glAttachShader(program, fragmentShader);</span><br><span class="line">            checkGlError(<span class="string">"glAttachShader"</span>);</span><br><span class="line">            GLES20.glLinkProgram(program);</span><br><span class="line">            <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(linkStatus[<span class="number">0</span>] != GLES20.GL_TRUE) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"link program error:"</span> + GLES20.glGetProgramInfoLog(program));</span><br><span class="line">                program = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> program;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载着色器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shaderType 着色器类型</span></span><br><span class="line"><span class="comment">     *                   &lt;p&gt;GLES20.GL_VERTEX_SHADER:顶点着色器</span></span><br><span class="line"><span class="comment">     *                   &lt;p&gt;GLES20.GL_FRAGMENT_SHADER:片元着色器&lt;p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 着色器的glsl代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 着色器id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loadShader</span><span class="params">(<span class="keyword">int</span> shaderType, String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shader = GLES20.glCreateShader(shaderType); <span class="comment">//根据着色器type创建一个着色器，返回其id</span></span><br><span class="line">        <span class="keyword">if</span>(shader != <span class="number">0</span>) &#123;</span><br><span class="line">            GLES20.glShaderSource(shader, source); <span class="comment">//将着色器与源代码绑定</span></span><br><span class="line">            GLES20.glCompileShader(shader);     <span class="comment">//编译</span></span><br><span class="line">            <span class="keyword">int</span>[] compiled = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取Shader的编译情况</span></span><br><span class="line">            GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(compiled[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"compile error:"</span> + shaderType);</span><br><span class="line">                Log.e(TAG, <span class="string">"compile error:"</span> + GLES20.glGetShaderInfoLog(shader));</span><br><span class="line">                GLES20.glDeleteShader(shader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-顶点着色器和片元着色器"><a href="#3-顶点着色器和片元着色器" class="headerlink" title="3.顶点着色器和片元着色器"></a>3.顶点着色器和片元着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl  顶点着色器</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uMVPMatrix;        <span class="comment">//变换矩阵</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aPosition;              <span class="comment">//初始顶点坐标</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> aColor;                  <span class="comment">//顶点颜色</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> vColor;                    <span class="comment">//传递给片元着色器的顶点颜色</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = uMVPMatrix * <span class="type">vec4</span>(aPosition, <span class="number">1</span>);      <span class="comment">//将初始顶点和变换矩阵做矩阵乘法，得到变换后的顶点坐标，赋给内建变量</span></span><br><span class="line">    vColor = aColor;                                    <span class="comment">//vColor传递给片元着色器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl    片元着色器</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;    <span class="comment">//指定片元着色器float精度为中</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> vColor;        <span class="comment">//由顶点传入的经过插值化的颜色值</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = vColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Model类开发"><a href="#4-Model类开发" class="headerlink" title="4.Model类开发"></a>4.Model类开发</h3><p>在外部程序中获取glsl程序中该变量对应id-&gt;初始化缓冲区-&gt;draw的时候将缓冲区数据送入渲染管线。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三角形的Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Triangle"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体物体的3D变换矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span>[] mMMartrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mProgram;   <span class="comment">//程序id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点着色器中 uniform mat4 uMVPMatrix 变量id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> muMVPMatrixHandle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点着色器中 attribute vec3 aPosition 变量id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> maPositionHandle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点着色器中 attribute vec4 aColor 变量id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> maColorHandle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点着色器代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String mVertexShader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 片元着色器代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String mFragmentShader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始顶点数据的缓冲区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FloatBuffer mVertexBuffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始颜色数据的缓冲区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FloatBuffer mColorBuffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> vCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前绕X轴旋转的角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">float</span> xAngle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span><span class="params">(Resources resources)</span> </span>&#123;</span><br><span class="line">        initVertexData();</span><br><span class="line">        initShader(resources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Array 长度分配和顶点个数有关系：顶点个数 * 每个顶点需要多少个分量,vec3就是3个分量</span></span><br><span class="line"><span class="comment">     * ByteBuffer长度分配和Array长度有关系：Array长度 * Array一个元素占多少个字节(一个float为4个字节)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVertexData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> UNIT_SIZE = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点位置数据： 3个顶点，每个顶点位置为(x,y,z)的vec3数据</span></span><br><span class="line">        <span class="keyword">float</span>[] vertexArray = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">                -<span class="number">4</span>*UNIT_SIZE, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1</span></span><br><span class="line">                <span class="number">0</span>, -<span class="number">4</span>*UNIT_SIZE, <span class="number">0</span>, <span class="comment">//顶点2</span></span><br><span class="line">                <span class="number">4</span>*UNIT_SIZE,<span class="number">0</span> , <span class="number">0</span>   <span class="comment">//顶点3</span></span><br><span class="line">        &#125;;</span><br><span class="line">        mVertexBuffer = ByteBuffer.allocateDirect(vertexArray.length * <span class="number">4</span>)</span><br><span class="line">                .order(ByteOrder.nativeOrder()) <span class="comment">//之所以不直接用FloatBuffer.allocate方法是因为只有ByteBuffer有nativeOrder()方法</span></span><br><span class="line">                .asFloatBuffer()</span><br><span class="line">                .put(vertexArray);</span><br><span class="line">        mVertexBuffer.position(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点颜色数据： 3个顶点，每个顶点颜色为(r,g,b,a)的vec4数据</span></span><br><span class="line">        <span class="keyword">float</span>[] colorArray = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">                <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1</span></span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点2</span></span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment">//顶点3</span></span><br><span class="line">        &#125;;</span><br><span class="line">        mColorBuffer = ByteBuffer.allocateDirect(colorArray.length * <span class="number">4</span>)</span><br><span class="line">                .order(ByteOrder.nativeOrder())</span><br><span class="line">                .asFloatBuffer()</span><br><span class="line">                .put(colorArray);</span><br><span class="line">        mColorBuffer.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initShader</span><span class="params">(Resources resources)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从glsl文件中加载着色器代码，当然也可以在Java代码中写死</span></span><br><span class="line">        mVertexShader = ShaderUtil.loadFromAssetsFile(<span class="string">"vertex.glsl"</span>, resources);</span><br><span class="line">        mFragmentShader = ShaderUtil.loadFromAssetsFile(<span class="string">"fragment.glsl"</span>, resources);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(mVertexShader) || TextUtils.isEmpty(mFragmentShader)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"load vertexShader or fragmentShader source code failed."</span>);</span><br><span class="line">            Log.e(TAG, <span class="string">"vertexShader: "</span> + mVertexShader);</span><br><span class="line">            Log.e(TAG, <span class="string">"fragmentShader: "</span> + mFragmentShader);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mProgram = ShaderUtil.createProgram(mVertexShader, mFragmentShader);</span><br><span class="line">        <span class="keyword">if</span>(mProgram == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"createProgram failed."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取需要java层传给GL层的变量的id</span></span><br><span class="line">        maPositionHandle = GLES20.glGetAttribLocation(mProgram, <span class="string">"aPosition"</span>);</span><br><span class="line">        maColorHandle = GLES20.glGetAttribLocation(mProgram, <span class="string">"aColor"</span>);</span><br><span class="line">        muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, <span class="string">"uMVPMatrix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用OpenGL画出自己，一般在GLSurfaceView.Render的onDrawFrame中调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GLES20.glUseProgram(mProgram);</span><br><span class="line">       <span class="comment">//在每次draw的时候初始化变换矩阵，然后进行矩阵变换，如果不调用会出现以下两种情况</span></span><br><span class="line">       <span class="comment">//①变换矩阵为全0矩阵，无法渲染</span></span><br><span class="line">       <span class="comment">//②变换矩阵还保留着上一次的值，渲染异常</span></span><br><span class="line">        Matrix.setRotateM(mMMartrix, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);    </span><br><span class="line">         <span class="comment">// 对物体顶点进行各种变换，当然也可以不操作直接把原始顶点画上去。</span></span><br><span class="line">        Matrix.rotateM(mMMartrix, <span class="number">0</span>, xAngle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于attribute变量，需要enable</span></span><br><span class="line">        GLES20.glEnableVertexAttribArray(maPositionHandle);</span><br><span class="line">        GLES20.glEnableVertexAttribArray(maColorHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将需要传给着色器的变量通过id送入渲染管线</span></span><br><span class="line">        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, <span class="number">1</span>, <span class="keyword">false</span>, MatrixState.getFinalMatrix(mMMartrix), <span class="number">0</span>);   <span class="comment">//getFinalMatrix是将物体本来的变换矩阵与摄像机矩阵、投影矩阵相乘而得出的最终的变换矩阵，这个矩阵已经是投影到近平面上的矩阵了，关于摄像机和投影可以看下篇文章</span></span><br><span class="line">        GLES20.glVertexAttribPointer(</span><br><span class="line">        maPositionHandle,   <span class="comment">//顶点着色器变量id</span></span><br><span class="line">        <span class="number">3</span>,                  <span class="comment">//着色器中该变量有几个分量,aPosition是vec3，所以是3个</span></span><br><span class="line">        GLES20.GL_FLOAT,    <span class="comment">//着色器中该变量类型,vec是float型</span></span><br><span class="line">        <span class="keyword">false</span>,</span><br><span class="line">        <span class="number">3</span>*<span class="number">4</span>,                <span class="comment">//一次从Buffer中取多少数据作为该变量的值。这里一个vec3顶点有3个分量，每个分量为float型，所以每次取值跨越的字节数为 3*4bytes = 12bytes</span></span><br><span class="line">        mVertexBuffer);     <span class="comment">//缓冲区</span></span><br><span class="line">        GLES20.glVertexAttribPointer(maColorHandle, <span class="number">4</span>, GLES20.GL_FLOAT, <span class="keyword">false</span>, <span class="number">4</span>*<span class="number">4</span>, mColorBuffer);</span><br><span class="line"></span><br><span class="line">        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, <span class="number">0</span>, vCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-GLSurfaceView"><a href="#5-GLSurfaceView" class="headerlink" title="5.GLSurfaceView"></a>5.GLSurfaceView</h3><p>要使用OpenGL渲染，需要GLSurfaceView的EGL环境，这里通过继承GLSurfaceView实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySurfaceView</span> <span class="keyword">extends</span> <span class="title">GLSurfaceView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> ANGLE_SPAN = <span class="number">0.375f</span>;</span><br><span class="line">    RotateThread rthread;</span><br><span class="line">    SceneRender mRender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setEGLContextClientVersion(<span class="number">2</span>);  <span class="comment">//设置OpenGL版本为2.x</span></span><br><span class="line">        mRender = <span class="keyword">new</span> SceneRender();</span><br><span class="line">        setRenderer(mRender);</span><br><span class="line">        <span class="comment">// 设置渲染模式，RENDERMODE_CONTINUOUSLY为底层不停调用onDrawFrame进行渲染</span></span><br><span class="line">        <span class="comment">//  RENDERMODE_WHEN_DIRTY为只有当onSurfaceCreated时和主动调用requestRender时才会发起渲染</span></span><br><span class="line">        setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SceneRender</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Triangle tle;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">            GLES20.glClearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>); <span class="comment">// 屏幕背景色</span></span><br><span class="line">            GLES20.glEnable(GLES20.GL_DEPTH_TEST);  <span class="comment">// 开启深度检测</span></span><br><span class="line">            tle = <span class="keyword">new</span> Triangle(getResources());</span><br><span class="line">            rthread = <span class="keyword">new</span> RotateThread();</span><br><span class="line">            rthread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">//设置视口</span></span><br><span class="line">            <span class="keyword">float</span> ratio = (<span class="keyword">float</span>)width / height;</span><br><span class="line">            MatrixState.setProjectFrustum(-ratio, ratio, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 设置投影矩阵：透视投影</span></span><br><span class="line">            MatrixState.setCamera(  <span class="comment">//设置摄像机矩阵</span></span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line">                    <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">                    <span class="number">0f</span>, -<span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">            <span class="comment">//关于投影矩阵和摄像机矩阵，可以看文章：摄像机和投影</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 每一次都需要清除存在于帧缓冲中的上一次的深度缓存和颜色缓存，不然会将上一帧的内容也画上去</span></span><br><span class="line">            GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);    </span><br><span class="line">            tle.drawSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//通过不停改变xAngle达到一种绕x轴旋转的效果</span></span><br><span class="line">                mRender.tle.xAngle += ANGLE_SPAN;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/OpenGL-2-着色语言/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/OpenGL-2-着色语言/" itemprop="url">OpenGL(2) - 着色语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-02T17:36:29+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="OpenGL-2-着色语言"><a href="#OpenGL-2-着色语言" class="headerlink" title="OpenGL(2) - 着色语言"></a>OpenGL(2) - 着色语言</h1><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>标量：</strong>bool,int,float<br><strong>向量：</strong>vec2,vec3,vec4,ivec2,ivec3,ivec4,bvec2,bvec3,bvec4，数字代表该向量是几维向量，vec为float向量，ivec为int向量，bvec为bool向量。<br>将一个向量看为颜色时，最多使用4个分量：[argb]<br>将一个向量看为位置时，最多使用4个分量：[x,y,z,w]，w为齐次坐标，一般为1<br>将一个向量看为纹理时，最多使用4个分量：[s,t,p,q]<br>访问向量中分量的语法为:<strong>&lt;向量名&gt;·&lt;分量名&gt;</strong>，或者使用下标，如：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> position = <span class="type">vec3</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">//构造一个vec3的标量</span></span><br><span class="line">position.x = <span class="number">10</span>;    <span class="comment">//将x分量置为10</span></span><br><span class="line">position[<span class="number">1</span>] = <span class="number">20</span>;   <span class="comment">//将y分量置为20</span></span><br></pre></td></tr></table></figure></p>
<p><strong>矩阵：</strong>mat2,mat3,mat4，都为float矩阵，数字代表几维矩阵<br>在OpenGL中，矩阵是按照列来组织的，所以可以将矩阵视为多个列向量的数组来访问，如：<br>一个矩阵赋值如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  第1列 | 第2列 | 第3列</span><br><span class="line">1 | 2 | 3 </span><br><span class="line">4 | 5 | 6</span><br><span class="line">7 | 8 | 9</span><br></pre></td></tr></table></figure></p>
<p>则在着色语言的访问方式：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mat3</span> m3;</span><br><span class="line"><span class="type">vec3</span> v1 = m3[<span class="number">0</span>];    <span class="comment">// v1为(1,4,7)</span></span><br><span class="line"><span class="type">float</span> f = m3[<span class="number">1</span>][<span class="number">2</span>];     <span class="comment">// f为8</span></span><br></pre></td></tr></table></figure></p>
<p><strong>采样器：</strong>sampler2D,sampler3D,samplerCube<br>sampler2D：二维纹理采样器<br>sampler3D：三维纹理采样器<br>samplerCube：立方体贴图采样器<br><strong>结构体:</strong><br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct info &#123;</span><br><span class="line">    <span class="type">vec3</span> color;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">vec2</span> textureColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>数组</strong><br><strong>空类型</strong>：void</p>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下初始化方式都是正确的</span></span><br><span class="line"><span class="type">float</span> a = <span class="number">2.3</span>;</span><br><span class="line"><span class="type">vec3</span> v1 = <span class="type">vec3</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">vec3</span> v2 = <span class="type">vec3</span>(v1.x, v1.y, <span class="number">100</span>);</span><br><span class="line"><span class="type">vec4</span> v3 = <span class="type">vec4</span>(v2, <span class="number">200</span>);</span><br><span class="line"><span class="type">mat3</span> m1 = <span class="type">mat3</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"><span class="type">mat3</span> m2 = <span class="type">mat3</span>(v3, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"><span class="type">mat3</span> m3 = <span class="type">mat3</span>(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-运算符之混合操作"><a href="#3-运算符之混合操作" class="headerlink" title="3.运算符之混合操作"></a>3.运算符之混合操作</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下混合操作方式都为正确的</span></span><br><span class="line"><span class="type">vec4</span> color = <span class="type">vec4</span>(<span class="number">0.7</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">vec3</span> temp = color.agb;</span><br><span class="line"><span class="type">vec4</span> tempL = color.aabb;</span><br><span class="line">tempLL.grb = color.aab;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为不正确的</span></span><br><span class="line">temp = color.xya;   <span class="comment">//xy 和  a不在同一组，xy为位置分量，a为颜色分量</span></span><br></pre></td></tr></table></figure>
<h3 id="4-片元着色器中的浮点变量精度指定"><a href="#4-片元着色器中的浮点变量精度指定" class="headerlink" title="4.片元着色器中的浮点变量精度指定"></a>4.片元着色器中的浮点变量精度指定</h3><p>顶点着色器直接声明变量就可以使用，但片元着色器中的变量需要手动指定，不然会编译错误，分为3种精度：</p>
<ul>
<li>lowp 低精度</li>
<li>mediump 中精度</li>
<li>highp 高精度<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lowp</span> <span class="type">float</span> color;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">mediump</span> <span class="type">vec2</span> position;</span><br><span class="line"><span class="keyword">highp</span> <span class="type">mat4</span> m;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果希望片元着色器的float变量都使用同一种精度，则在最开始的地方声明：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// precision &lt;精度&gt; &lt;类型&gt;</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-限定符"><a href="#5-限定符" class="headerlink" title="5.限定符"></a>5.限定符</h3><p><strong>attribute：</strong>只能顶点着色器使用，由外部程序传入顶点着色器。<br><strong>uniform：</strong>一致变量限定符，指的是在单个3D物体中所有顶点都相同的值，uniform可以用在顶点着色器和片元着色器中，它的值也是通过外部程序传入。<br><strong>varying：</strong>易变变量，它修饰的变量可以从顶点着色器中传入片元着色器中，但是片元着色器真正获得的值会根据各个顶点传递的值，通过渲染管线的插值计算出每个片元的值。<br><strong>const：</strong>常量限定，和C语言语法一致。</p>
<h3 id="6-内建变量"><a href="#6-内建变量" class="headerlink" title="6.内建变量"></a>6.内建变量</h3><p><strong>顶点着色器中的内建变量：</strong>gl_Position,gl_PointSize等</p>
<ul>
<li><p>gl_Position(vec4)：顶点着色器从外部程序接收到顶点的原始坐标后，和变换矩阵计算得出的最终顶点坐标，需要赋给这个值，gl_Position赋值后会送入渲染管线后续流程继续处理，几乎在所有的顶点着色器中都需要给它赋值。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uMVPMatrix;    <span class="comment">//变换矩阵</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aPosition;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = uMVPMatrix * <span class="type">vec4</span>(aPosition, <span class="number">1</span>);  <span class="comment">//矩阵乘法，算出最终坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>gl_PointSize(float)：计算一个点的大小，默认为1</p>
</li>
</ul>
<p><strong>片元着色器中的内建输入变量:</strong></p>
<ul>
<li><p>gl_FragCoord:内建输入变量，当前片元相对于窗口位置的坐标值x,y,z,1/w<br><img src="/2017/09/02/OpenGL-2-着色语言/test.png?r=40" alt=""></p>
</li>
<li><p>gl_FrontFacing(bool)：判断当前正在处理的片元是否属于在光栅化阶段生成此片元的对应图元的正面，一般用于开发双面光照功能相关的应用程序中。<br><strong>片元着色器中的内建输出变量</strong></p>
</li>
<li>gl_FragColor(vec4)：由片元着色器写入计算完成的片元的颜色值，可以通过 外部程序-&gt;顶点着色器-&gt;片元着色器传入。在OpenGL的纹理开发中，也可以通过外部程序传入纹理坐标后，通过纹理坐标去一张纹理图片上提取出颜色值。</li>
<li>gl_FragData(vec4[])：变量值是一个数组。向gl_FragData[n]写入数据时为了指明后续固定功能管线要使用的片元数据n。如果后续固定功能管线要使用这个片元数据，但是着色器又没有给它写入值，那么片元数据将是一个未定义的值。</li>
</ul>
<h3 id="7-内建函数"><a href="#7-内建函数" class="headerlink" title="7.内建函数"></a>7.内建函数</h3><p>着色器中的内建函数大致分为以下几种</p>
<ul>
<li>角度转换和三角函数（radians、sin、cos…）</li>
<li>指数函数（pow、log…）</li>
<li>常见函数（abs、mod…）</li>
<li>几何函数（length、cross..）</li>
<li>矩阵函数（martrixCompMult..）</li>
<li>向量关系函数（lessThan、equal..）</li>
<li>纹理采样函数（texture2D、textureCube、texture3D…）</li>
<li>微分函数（dFdx..）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/31/OpenGL-1-渲染管线/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/31/OpenGL-1-渲染管线/" itemprop="url">OpenGL(1) - 渲染管线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-31T21:12:30+08:00">
                2017-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h1 id="OpenGL-1-渲染管线"><a href="#OpenGL-1-渲染管线" class="headerlink" title="OpenGL(1) - 渲染管线"></a>OpenGL(1) - 渲染管线</h1><h3 id="OpenGL-ES2-x渲染管线"><a href="#OpenGL-ES2-x渲染管线" class="headerlink" title="OpenGL ES2.x渲染管线"></a>OpenGL ES2.x渲染管线</h3><p><img src="/2017/08/31/OpenGL-1-渲染管线/渲染管线.png" alt=""></p>
<h3 id="VertexShader"><a href="#VertexShader" class="headerlink" title="VertexShader"></a>VertexShader</h3><p>顶点着色器，由外部程序传入顶点原始信息至顶点着色器中，一般在里面计算出最终顶点位置、颜色等各项顶点属性信息，然后将其传递给图元装配阶段。每个顶点执行一次。</p>
<p><img src="/2017/08/31/OpenGL-1-渲染管线/顶点着色器.png" alt=""><br>attribute 0~n：外部程序传入的变量，每个顶点都独有一份。<br>uniforms：外部程序传入的常量数据，同一个3D物体的所有顶点共有一份。<br>samplers：这个是可选的，一种特殊的 Uniforms ，表示顶点着色器使用的纹理。<br>varying 0~n：顶点着色器计算出传递给片元着色器的变量，但是这个变量并不是直接将赋的值送入片元着色器中，而是根据每个顶点对此易变变量的赋值情况和片元与顶点的位置关系，经过插值计算后，再传递给片元。</p>
<p><img src="/2017/08/31/OpenGL-1-渲染管线/varying插值计算.png" alt=""></p>
<h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p><img src="/2017/08/31/OpenGL-1-渲染管线/图元装配.png" alt=""><br>经过着色器处理之后的顶点在图元装配阶段被装配为基本图元，图元是一个能用OpenGL ES绘图命令绘制的几何体，绘图命令指定了一组顶点属性，描述了图元的几何形状和图元类型，OpenGL ES 支持三种基本图元：点，线和三角形，它们是可被 OpenGL ES 渲染的。<br>图元处理最重要的工作为<strong>剪裁</strong>，它将在可视区域外的图元丢弃，可视区域是由摄像机位置和投影位置产生的6个平面的视景体决定的。其中，近平面为投影平面。</p>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p><img src="/2017/08/31/OpenGL-1-渲染管线/光栅化.png" alt=""></p>
<p><strong>投影</strong><br>由于显示设备都是二维的，所以需要将上一步剪裁得到的3D物体投影到近平面上。</p>
<p><img src="/2017/08/31/OpenGL-1-渲染管线/视景体.png" alt=""></p>
<p><strong>光栅化</strong></p>
<p><img src="/2017/08/31/OpenGL-1-渲染管线/光栅化1.png" alt=""></p>
<p>将由各个顶点形成的几何物体，经过一系列变换后，形成一个个离散化的小单元，这个小单元被称为片元，每个片元对应帧缓冲的一个像素，但是在3D世界中物体是会相互遮挡的，这点在每个片元中也存在，每个通过对比每个片元的深度属性，深度低的会覆盖掉深度高的片元，所以最终在屏幕上显示的像素为最上面片元的像素。</p>
<h3 id="FragmentShader"><a href="#FragmentShader" class="headerlink" title="FragmentShader"></a>FragmentShader</h3><p>片元着色器，若干个顶点经过顶点着色器-&gt;图元装配-&gt;光栅化后，得到了若干个片元，每个片元执行一次，在里面可以进行纹理的采样，颜色的汇总。计算出最终颜色赋值给内建变量。</p>
<p><img src="/2017/08/31/OpenGL-1-渲染管线/片元着色器.png" alt=""><br>varying 0~n：从顶点着色器传递到片元着色器的变量，如上所说，是经过插值化后的变量。<br>gl_FragColor：内建变量，指该片元的颜色</p>
<p>注：容易看出，片元着色器运行的次数是远远大于顶点着色器的，所以如果某些重复的运算最好在顶点着色器中完成，避免影响执行效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/06/涂鸦模块实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slim">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slim's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/06/涂鸦模块实现/" itemprop="url">涂鸦模块实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-06T20:51:06+08:00">
                2016-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p class="description"></p>

<p><img src="" class="img-topic"></p>
<p><br></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>添加文字，文字可以拖动缩放旋转</li>
<li>添加多个表情，表情可以拖动缩放旋转</li>
<li>添加涂鸦，用手指在屏幕上画出形状，支持撤销和换色</li>
</ul>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-49-27.png" alt=""></p>
<h2 id="整体设计和代码实现"><a href="#整体设计和代码实现" class="headerlink" title="整体设计和代码实现"></a>整体设计和代码实现</h2><p>如何实现需求，这里了采取一个View承载多个Layer的方法：</p>
<ul>
<li>Layer：逻辑上的“层”，一个层独立负责一个涂鸦类型，比如需求说的：文字层，表情层和涂鸦层。Layer最重要的三个方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个ACTION_DOWN发生时，判断自己需不需要这次的TouchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(MotionEvent event)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//处理MotionEvent</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dealTouch</span><span class="params">(MotionEvent event)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将自己画出来</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>View：内部维护了一个<code>List&lt;Layer&gt;</code>，并完成以下两种工作：<ol>
<li>负责接收发生的TouchEvent并完成向Layer的分发TouchEvent</li>
<li>向Layer提供Canvas，让他们画出来</li>
</ol>
</li>
</ul>
<p>List中的Layer是有优先级的，排在越靠后的Layer具有越高的优先级，优先级越高，摆在View中的位置也就比其他Layer”高”，换句话或就是z大。最高优先级的Layer会最先收到TouchEvent，并在绘制的时候绘制在最上面。</p>
<p>事件流程：</p>
<ul>
<li>当用户手指触摸到屏幕上时，首先发生ACTION_DOWN，DoodleView会从后往前遍历<code>List&lt;Layer&gt;</code>，调用Layer的accept去问这个Layer需不需要处理这一次的MotionEvent，如果在遍历的过程中有一个Layer的accept的方法返回了true，代表它要消费这次事件，那么DoodleView会记下这个Layer并立即结束遍历。并将这一次的所有TouchEvent事件都交给这个Layer的dealTouch()处理。</li>
<li>每一次DoodleView的onTouchEvent调用，都会调用一次invalidate()重绘界面，在它的onDraw方法中，会从前往后的遍历<code>List&lt;Layer&gt;</code>，取出Layer调用它的draw()方法画出来，这就保证了排在List中最后的Layer会画在其他Layer上面。</li>
</ul>
<p><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-24-10.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画图，画在外部传进的Canvas上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理TouchEvent事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dealTouch</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断需不需要TouchEvent事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DoodleView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 每一次的down事件，都去从上往下寻找需要处理的Layer，如果找到，今后的Event事件都给它处理</span></span><br><span class="line"><span class="comment">        * 如果没有找到，则交给EmptyLayer处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> (mActiveLayer == mEmptyLayer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            mActiveLayer = findActiveLayer(event);</span><br><span class="line">            mActiveLayer.requestActive(<span class="keyword">true</span>);</span><br><span class="line">            SLog.d(TAG,mActiveLayer.toString() + <span class="string">" hold the TouchEvent."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mActiveLayer.dealTouch(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从最上面的Layer往下，判断哪个层需要这次的事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseLayer <span class="title">findActiveLayer</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = mLayerList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        BaseLayer layer = mLayerList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (layer.accept(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> layer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有层需要此次事件</span></span><br><span class="line">    <span class="keyword">return</span> mEmptyLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DoodleView#onDraw：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnable) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;String,BaseLayer&gt; layerEntry : mLayerMap.entrySet()) &#123;</span><br><span class="line">        BaseLayer layer = layerEntry.getValue();</span><br><span class="line">        layer.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手势处理"><a href="#手势处理" class="headerlink" title="手势处理"></a>手势处理</h2><p>整理好了总体的框架，现在要去实现里面的细节：如何处理TouchEvent实现各种旋转缩放平移的手势，这里用到了一个类：Matrix，关于Matrix的详解：<a href="http://blog.csdn.net/cquwentao/article/details/51445269" target="_blank" rel="noopener">http://blog.csdn.net/cquwentao/article/details/51445269</a></p>
<p>在涂鸦功能中，每一个可以被手势拖动缩放的东西：一个表情，一行文字，都看做一个DoodleItem，一个DoodleItem有以下四个基本属性。</p>
<ul>
<li>宽(width)、高(height)、初始的中心点坐标(centerPoint)，通过这些值可以确定一个DoodleItem在屏幕上的初始位置和大小。</li>
<li>相对于初始中心点，变换后的中心点在XY轴的平移量(translateX，translateY)，初始为0。</li>
<li>缩放值(scale)，初始为1</li>
<li>旋转角度(rotate)，初始为0。</li>
</ul>
<p><strong>每一个DoodleItem在屏幕上的形状，位置，都认为是由中心点在屏幕原点的DoodleItem(叫它基础Item)经过变换得到的（这一点是理解矩阵变换的基础），即使是一开始添加到屏幕上的DoodleItem，也是由在屏幕原点的DoodleItem平移centerPoint得到的。</strong></p>
<p><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-24-55.png" alt=""></p>
<p>上图是一个DoodleItem进行变换的三个状态。在绘制过程中，通过Matrix，顺序的进行对Matrix进行以下变换(一般来说，平移是在最后进行的，因为scale和rotate操作都是相对于原点的，而一开始的原点就是Item的中心点，刚好就能实现相对于中心点的旋转缩放。如果先平移，中心点就不再是原点了，这样缩放和旋转还相对于原点就会出问题)：</p>
<ol>
<li>scale,rotate变换</li>
<li>平移到初始centerP位置</li>
<li>平移translateX,translateY</li>
</ol>
<p>我们就可以认为，A上任何一个点，经过该Matrix变换后，得到的是C上对应的点，A上所有点经过Matrix变换后就得到了C。如果将这个Matrix作用在Canvas上，就可以把画布的坐标系调整为以下效果：<br><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-25-32.png" alt=""></p>
<p>直接对Canvas进行矩阵变换的好处就是，画布已经进行了scale值的缩放，直接画原来的width和height就可以了，不用对原本的width和height自己进行scale和rotate。如果是画图片，直接调用drawable.draw(Canvas)便可将图片画出来。</p>
<p>一个Layer，其实就是管理着里面很多DoodleItem一个容器，在Layer的dealTouch方法中，主要改变的是，被操作DoodleItem的translateX，translateY，scale，rotate。绘制流程主要是画出每一个DoodleItem，而画每一个DoodleItem的过程，其实就是利用这个DoodleItem的translateX，translateY，scale，rotate这些值，生成一个变换矩阵，将这个矩阵作用到Canvas上，就可以将Canvas的坐标系原点转换到每一个DoodleItem的中心点上，然后进行绘制。 </p>
<p>那么，是怎样改变DoodleItem的四个值的，我独立出一个类(GestureHelper)用来处理DoodleItem的TouchEvent事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GestureHelper</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将Touch事件交给Manager处理</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> needScale  是否支持单指缩放旋转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> needScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction() &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            dealDown(event, needScale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">            dealPointerDown(event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            dealMove(event, needScale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">            dealPointerUp(event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            dealUp(event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="translateX-translateY"><a href="#translateX-translateY" class="headerlink" title="translateX,translateY"></a>translateX,translateY</h3><p>平移在单指和双指都可以操作，所以应该分开情况去计算平移量</p>
<h4 id="单指情况下"><a href="#单指情况下" class="headerlink" title="单指情况下"></a>单指情况下</h4><p><strong>ACTION_DOWN</strong>：主要是记录初始值。比如手指按下的startX,startY<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealDown</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> needScale)</span> </span>&#123;</span><br><span class="line">    mActionDown = <span class="keyword">true</span>;</span><br><span class="line">    mState = STATE_DRAG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> x = event.getX(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span> y = event.getY(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mStartX = x;</span><br><span class="line">    mStartY = y;</span><br><span class="line"></span><br><span class="line">    mOldTranslateXValue = mItem.translateXValue;</span><br><span class="line">    mOldTranslateYValue = mItem.translateYValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ACTION_MOVE</strong>：根据startX,startY计算偏移量，重新赋给translateX,translateY<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealMove</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> needScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mActionDown) &#123;</span><br><span class="line">        <span class="comment">//如果move调用之前没有调用过down事件，说明这是一个从move传进来的事件，需要把第一个move事件当做down事件来设置初始值</span></span><br><span class="line">        mActionDown = <span class="keyword">true</span>;</span><br><span class="line">        dealDown(event, needScale);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.getPointerCount() == <span class="number">1</span> &amp;&amp; mState == STATE_DRAG) &#123;</span><br><span class="line">        <span class="comment">//单指拖拽</span></span><br><span class="line">        <span class="keyword">if</span>(mActionPointerUp) &#123;</span><br><span class="line">            <span class="comment">//是ACTION_POINTER_UP后的第一次move事件，设置初始值作为之后Move的参考</span></span><br><span class="line">            mActionPointerUp = <span class="keyword">false</span>;</span><br><span class="line">            mStartX = event.getX(<span class="number">0</span>);</span><br><span class="line">            mStartY = event.getY(<span class="number">0</span>);</span><br><span class="line">            mOldTranslateXValue = mItem.translateXValue;</span><br><span class="line">            mOldTranslateYValue = mItem.translateYValue;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> dX = event.getX(<span class="number">0</span>) - mStartX;</span><br><span class="line">        <span class="keyword">float</span> dY = event.getY(<span class="number">0</span>) - mStartY;</span><br><span class="line"></span><br><span class="line">        mItem.translateXValue = mOldTranslateXValue + dX;</span><br><span class="line">        mItem.translateYValue = mOldTranslateYValue + dY;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="双指情况下"><a href="#双指情况下" class="headerlink" title="双指情况下"></a>双指情况下</h4><p>不再使用ACTION_DOWN中手指的startX,startY作为初始点，而是使用两根手指的中点作为初始点</p>
<p><strong>ACTION_POINTER_DOWN</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealPointerDown</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">float</span> y = event.getY(<span class="number">1</span>);</span><br><span class="line">    mItem.isDualFinger = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState == STATE_DRAG || mState == STATE_DRAG_ONE_POINT) &#123;</span><br><span class="line">        mState = STATE_CONTROL;</span><br><span class="line">        mOldScaleValue = mItem.scaleValue;</span><br><span class="line">        mOldRotateValue = mItem.rotateValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从单指拖动变成双指拖动，OldTranslateValue重新记录</span></span><br><span class="line">        mOldTranslateXValue = mItem.translateXValue;</span><br><span class="line">        mOldTranslateYValue = mItem.translateYValue;</span><br><span class="line"></span><br><span class="line">        mStartDistance = GestureUtil.spacing(event);</span><br><span class="line">        mStartDegree = GestureUtil.computeDegreeBySin(event);</span><br><span class="line">        <span class="keyword">float</span>[] f = GestureUtil.computeCenterPoint(event);</span><br><span class="line">        mStartCenterX = f[<span class="number">0</span>];</span><br><span class="line">        mStartCenterY = f[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ACTION_MOVE</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealMove</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> needScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mActionDown) &#123;</span><br><span class="line">        <span class="comment">//如果move调用之前没有调用过down事件，说明这是一个从move传进来的事件，需要把第一个move事件当做down事件来设置初始值</span></span><br><span class="line">        mActionDown = <span class="keyword">true</span>;</span><br><span class="line">        dealDown(event, needScale);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mItem.isKeep = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (event.getPointerCount() == <span class="number">1</span> &amp;&amp; mState == STATE_DRAG) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getPointerCount() == <span class="number">2</span> &amp;&amp; mState == STATE_CONTROL) &#123;</span><br><span class="line">        <span class="comment">//双指控制</span></span><br><span class="line">        <span class="keyword">float</span> currDistance = GestureUtil.spacing(event);</span><br><span class="line">        <span class="keyword">float</span> currDegree = GestureUtil.computeDegreeBySin(event);</span><br><span class="line">        <span class="keyword">float</span>[] f = GestureUtil.computeCenterPoint(event);</span><br><span class="line">        <span class="keyword">float</span> currCenterX = f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">float</span> currCenterY = f[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        mItem.scaleValue = mOldScaleValue * (currDistance / mStartDistance);</span><br><span class="line">        mItem.rotateValue = (mOldRotateValue + (currDegree - mStartDegree)) % <span class="number">360</span>;</span><br><span class="line">        mItem.translateXValue = mOldTranslateXValue + (currCenterX - mStartCenterX);</span><br><span class="line">        mItem.translateYValue = mOldTranslateYValue + (currCenterY - mStartCenterY);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>缩放只能双指缩放，所以只需要在ACTION_POINTER_DOWN记录初始值</p>
<p><strong>ACTION_POINTER_DOWN</strong><br>保存两根手指的距离<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealPointerDown</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">float</span> y = event.getY(<span class="number">1</span>);</span><br><span class="line">    mItem.isDualFinger = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState == STATE_DRAG || mState == STATE_DRAG_ONE_POINT) &#123;</span><br><span class="line">        mState = STATE_CONTROL;</span><br><span class="line">        ...</span><br><span class="line">        mOldScaleValue = mItem.scaleValue;<span class="comment">// 保存按下时的缩放值</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        mStartDistance = GestureUtil.spacing(event); <span class="comment">// 保存两根手指的距离</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ACTION_MOVE</strong><br>通过两根手指距离的变化算出scale<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> currDistance = GestureUtil.spaceing(event);</span><br><span class="line">mItem.scaleValue = mOldScaleValue * (currDistance / mStartDistance);</span><br></pre></td></tr></table></figure></p>
<h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><p>和scale处理逻辑类似，在ACTION_POINTER_DOWN记录两根手指的初始角度，在ACTION_MOVE中做增量处理赋给rotateValue就好了。</p>
<h3 id="将DoodleItem的各种值作用于Matrix"><a href="#将DoodleItem的各种值作用于Matrix" class="headerlink" title="将DoodleItem的各种值作用于Matrix"></a>将DoodleItem的各种值作用于Matrix</h3><p>得到一个DoodleItem对应的Matrix：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据DoodleItem的各种变量返回一个对应的矩阵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Matrix <span class="title">getMatrix</span><span class="params">(ZoomItem item)</span></span>&#123;</span><br><span class="line">    mMatrix.reset();</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mMatrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMatrix.postRotate(item.rotateValue);</span><br><span class="line">    mMatrix.postScale(getItemScale(item), getItemScale(item));</span><br><span class="line">    <span class="keyword">if</span>(item.centerP != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMatrix.postTranslate(item.centerP.x, item.centerP.y);</span><br><span class="line">    &#125;</span><br><span class="line">    mMatrix.postTranslate(item.translateXValue, item.translateYValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以在Layer的draw方法中，就是获取出这个Matrix对Canvas进行操作，拿FaceLayer(表情层)举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 画表情</span></span><br><span class="line"><span class="comment">* Rect的表示是通过两个点表示的，所以经过Matrix变换后的Rect已经变形，所以不能直接调用Canvas.drawRect画</span></span><br><span class="line"><span class="comment">* 这里采取的方法是将画布同样根据矩阵变换，变换后的坐标系就是一个Item自己的坐标系，原点是该Item的中点</span></span><br><span class="line"><span class="comment">* 通过这种方法就可以直接画出图案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawItem</span><span class="params">(FaceItem item,Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.concat(mGestureHelper.getMatrix(item));</span><br><span class="line">    item.draw(canvas, <span class="keyword">true</span>);</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在FaceItem的draw方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> isDraw 判断该方法调用是在draw还是save</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, <span class="keyword">boolean</span> isDraw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算可操作区域</span></span><br><span class="line">    <span class="keyword">float</span> width = <span class="keyword">this</span>.width;</span><br><span class="line">    <span class="keyword">float</span> height = <span class="keyword">this</span>.height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(width * scaleValue &lt; GestureHelper.MIN_HOT_SIZE) &#123;</span><br><span class="line">        width = GestureHelper.MIN_HOT_SIZE / scaleValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(height * scaleValue &lt; GestureHelper.MIN_HOT_SIZE) &#123;</span><br><span class="line">        height = GestureHelper.MIN_HOT_SIZE / scaleValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.save();</span><br><span class="line">    <span class="comment">// 经过Matrix变换的Canvas的圆点在Item的重点，如果直接调用drawable的draw方法，会从中点开始画</span></span><br><span class="line">    <span class="comment">// 图片见画在了右下角的位置，所以要做一个平移操作，将圆点移回DoodleItem左上角</span></span><br><span class="line">    canvas.translate(-<span class="keyword">this</span>.width / <span class="number">2</span>, -<span class="keyword">this</span>.height / <span class="number">2</span>);</span><br><span class="line">    drawable.draw(canvas);</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="逆矩阵的作用"><a href="#逆矩阵的作用" class="headerlink" title="逆矩阵的作用"></a>逆矩阵的作用</h3><p>DoodleItem经过变换后的Matrix，可以把相对于屏幕坐标系的点，变换到DoodleItem自身的坐标系中。这个矩阵的逆矩阵的作用则是反过来，将在DoodleItem自己坐标系中的点，变换到屏幕坐标系中。</p>
<p>如果需要判断用户的手指落下时的点，是否在DoodleItem的范围内，其实就是将手指按下的点，看成是在DoodleItem自身的坐标系中，是否在Item对应的width和height之内，经过平移缩放后的Item，已经不再是一个摆正的长方形，很难直接在Item自身的坐标系中判断这个点是否在Item中间，于是就需要逆矩阵将手指按下的点，重新变换到屏幕坐标系上，通过将变换后的点的坐标和基础Item的width和height比较，就很容易知道是否这个点是否落在Item中间。<br><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-45-09.png" alt=""><br><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-45-24.png" alt=""></p>
<p>在Layer的accept方法中，其实就是遍历它管理的Item，看看是否ACTION_DOWN落在了某个Item中间，如果是的话，就返回true，之后的MotionEvent就用来变换这个Item了。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="涂鸦图片大小的优化"><a href="#涂鸦图片大小的优化" class="headerlink" title="涂鸦图片大小的优化"></a>涂鸦图片大小的优化</h3><p>所有Layer的内容，都需要保存为一张涂鸦图片，我的做法是创建一张屏幕大小的Bitmap，使用Canvas去操作它，将这个Canvas传给所有Layer的draw(Canvas)，重新走一遍draw的逻辑，让Bitmap中有Layer的内容。</p>
<p><strong>优化原因</strong>：在一些分辨率高，屏幕大的手机中，生成的Bitmap会占用十几M内存，且重新走draw方法的时候耗时很长，有明显的卡顿，生成的图片文件也有十几M的大小，造成了时间和空间上的损耗。</p>
<p><strong>优化方法</strong>：其实作为呈现在视频上面的涂鸦图片来说，它对分辨率的要求不会太高，用户添加个表情，画几条线，不会要求观看的时候跟画出来一样清晰，所以在日迹中的策略是，生成的Bitmap为640*480，这样既保证了比较清晰的图片，也节省了空间和时间。</p>
<p>那么自然的就有个问题，比如用户的所有操作都是在1024<em>768的手机上，每一个DoodleItem的坐标值也是相对于1024</em>768保存的，而一张Bitmap只有640*480，在draw的时候不是很容易画出界吗？<br><img src="/2016/12/06/涂鸦模块实现/2019-01-24-20-46-10.png" alt=""></p>
<p>在这种情况下，可以根据屏幕的宽/高和生成的Bitmap的宽/高相除，算出缩放比scale(因为要等比缩放，所以只能采用宽和高中的一种比例，这取决于具体的业务需要宽对齐还是高对齐)，在重新走draw逻辑的时候之前先对Canvas进行一次缩放操作，这样画出来的DoodleItem都是根据Bitmap的宽高呈现的了。对此我给每一个Layer加了一个save()，来进行这种操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Canvas canvas, <span class="keyword">float</span> scaleValue, <span class="keyword">boolean</span> needDynamic)</span> </span>&#123;</span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.scale(scaleValue,scaleValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(FaceItem item : mFaceItems) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.concat(mGestureHelper.getMatrix(item));</span><br><span class="line">        item.draw(canvas, <span class="keyword">false</span>);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="给DoodleItem设置最小操作热区"><a href="#给DoodleItem设置最小操作热区" class="headerlink" title="给DoodleItem设置最小操作热区"></a>给DoodleItem设置最小操作热区</h3><p><strong>优化原因</strong>：在用户操作DoodleItem的过程中，如果将其缩放的很小很小，就会导致下一次的ACTION_DOWN判断区域过小，体现在用户很难点中想要操作的表情/文字。<br><strong>优化方法</strong>：在GestureHelper中，定下一个最小操作热区，在判断是否点中DoodleItem的方法中，进行width和height大小判断，如果大小乘上scale值比操作热区大小还小时，直接采用操作热区的大小作为Item判断时的区域大小。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Slim</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Slim</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
